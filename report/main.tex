\documentclass[11pt]{scrartcl} % Font size
% \usepackage{beamer}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[utf8]{inputenc} % Per l'encoding dei caratteri
\usepackage[T1]{fontenc} % Per la codifica dei font
\usepackage[italian]{babel}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}
\input{structure.tex} % Include the file specifying the document structure and custom commands


%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{
	\normalfont\normalsize
	\textsc{Università degli studi di Salerno}\\ % Your university, school and/or department name(s)
	\vspace{25pt} % Whitespace
	\rule{\linewidth}{0.5pt}\\ % Thin top horizontal rule
	\vspace{20pt} % Whitespace
	{\huge Progetto Programmazione e Strutture Dati}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
	\vspace{12pt} % Whitespace
}


\author{
	\LARGE
	Robustelli Renato \\
	\LARGE
	Squitieri Andrea \\
	\LARGE
	Vitolo Angelo
} % Your name

% \date{\normalsize\today} % Today's date (\today) or a custom date
\date{\null}


\begin{document}

\maketitle % Print the title

\tableofcontents

%----------------------------------------------------------------------------------------
%	FIGURE EXAMPLE
%----------------------------------------------------------------------------------------

\section{Introduzione}


%------------------------------------------------


Il progetto si concentra sulla creazione di un sistema di gestione delle conferenze, con l'obiettivo di organizzare e gestire eventi e stanze in modo efficiente. Il sistema è progettato per facilitare la pianificazione, la modifica, la visualizzazione e l'archiviazione di eventi e stanze all'interno di una conferenza.



\subsection{Obiettivi del progetto}
Gli obiettivi principali del progetto includono:

\begin{itemize}
	\item  Gestione di Conferenze: Possibilità di aggiungere, modificare e rimuovere eventi e stanze di una conferenza.
	\item Assegnazione delle Stanze: Funzionalità per assegnare stanze a specifici eventi.
	\item Visualizzazione delle Informazioni: Strumenti per visualizzare gli eventi ordinati per data d'inizio.
	\item Persistenza dei Dati: Capacità di salvare e caricare i dati delle conferenze da file per garantire la persistenza delle informazioni.
\end{itemize}

%----------------------------------------------------------------------------------------
%	TEXT EXAMPLE
%----------------------------------------------------------------------------------------

\section{Motivazione della scelta degli ADT}
\subsection{Motivazioni per l'uso dell'ADT RoomList}

Abbiamo deciso di utilizzare una lista per gestire le informazioni sulle sale all'interno del sistema di gestione delle conferenze per diverse ragioni. Le liste offrono flessibilità nella gestione dinamica delle sale, consentendo l'aggiunta e la rimozione efficiente di elementi in risposta alle variazioni nel numero di sale nel tempo. Inoltre, semplificano l'accesso e la ricerca delle sale, consentendo operazioni come l'ordinamento o la ricerca di una specifica sala in modo rapido ed efficiente.

Per implementare l'ADT RoomList, abbiamo scelto di utilizzare un array dinamico anziché una lista concatenata. Questa decisione è stata motivata da diverse considerazioni. Gli array dinamici offrono un accesso casuale più efficiente rispetto alle liste concatenate, il che si traduce in un'operatività più veloce e prevedibile per le operazioni che richiedono l'accesso non sequenziale alle sale nella lista.

Inoltre, gli array dinamici consentono un accesso continuo e contiguo alla memoria, migliorando la località dei dati e riducendo il numero di cache miss durante l'accesso ai dati nella lista. Questo porta a prestazioni ottimali in termini di accesso ai dati e di utilizzo della memoria.

Infine, l'utilizzo della memoria è più efficiente con gli array dinamici rispetto alle liste concatenate. Mentre una lista concatenata avrebbe utilizzato il doppio della memoria necessaria (un puntatore al valore e un puntatore al prossimo nodo), la nostra implementazione utilizza al massimo il doppio della memoria grazie all'utilizzo di un fattore di crescita per l'array dinamico che garantisce inoltre un numero limitato di spostamenti di dati durante il processo di reallocazione (il numero di spostamenti effettuati sarà sempre inferirore a 2n, dove n rappresenta il numero di sale).


\subsection{Motivazioni per l'uso dell'ADT EventBst}
Per gestire in modo ordinato la raccolta di eventi all'interno del sistema, abbiamo adottato un albero binario di ricerca. Questa scelta consente di aggiungere eventi con una complessità temporale media di \( O(\log{n}) \). Tuttavia, per garantire un'usabilità ottimale del software, le operazioni di modifica e rimozione degli eventi non sfruttano le proprietà dell'albero e sono quindi di complessità \( O(n) \), poiché precedute da una ricerca lineare per l'ID dell'evento.

Nonostante questa considerazione, riteniamo che l'utilizzo dell'albero di ricerca binario sia giustificato, dato che rappresenta un buon compromesso da un punto di vista computazionale. Altre strutture ordinate avrebbero mantenuto comunque una complessità temporale di \( O(n) \) per le operazioni di modifica e rimozione, rendendo però lineare anche la complessità dell'aggiunta degli eventi. La preferenza per una struttura ordinata è derivata dalla frequenza delle operazioni di visualizzazione degli eventi nel software, evitando così la necessità di ordinare la struttura prima di ogni operazione di visualizzazione, che potrebbe causare rallentamenti.


\section{Progettazione}

Il sistema di gestione delle conferenze è strutturato in modo modulare, suddiviso in vari componenti che interagiscono tra loro per fornire le funzionalità richieste. Ogni componente è stato progettato come un ADT per garantire una chiara separazione delle responsabilità e facilitare il mantenimento del codice.

\subsection{Moduli Principali}
I principali moduli del sistema sono:

\begin{itemize}
    \item \textbf{Date} (date.h): Gestisce le date e gli orari degli eventi.
    \item \textbf{Room} (room.h): Rappresenta le sale dove si tengono gli eventi.
    \item \textbf{RoomList} (room\_list.h): Gestisce una lista dinamica di sale.
    \item \textbf{Event} (mevent.h): Rappresenta gli eventi della conferenza.
    \item \textbf{EventBst} (event\_bst.h): Organizza gli eventi in un albero binario di ricerca per una gestione efficiente.
    \item \textbf{Conference} (conference.h): Coordina tutti gli elementi sopra menzionati, fornendo un'interfaccia unificata per la gestione della conferenza.
\end{itemize}

I componenti interagiscono tra loro attraverso chiamate a funzioni che rispettano i contratti definiti dai rispettivi ADT. Questa progettazione permette di mantenere un alto grado di incapsulamento e modularità.

\subsection{Gestione delle Date e Orari (Date)}
Il modulo \textbf{Date} è impiegato dai moduli \textbf{Event} e \textbf{Conference} per la gestione delle operazioni relative alle date e agli orari, come la creazione, il confronto e la validazione. Ad esempio, quando si crea un nuovo evento tramite il modulo \textbf{Event}, le funzioni di \textbf{Date} vengono utilizzate per definire con precisione la data e l'orario di inizio e fine. Questo modulo garantisce la validità delle date assegnate agli eventi, prevenendo conflitti temporali. Inoltre, permette di verificare che la data di inizio e quella di fine di un evento siano appropriate e che non vi siano due eventi programmati nella stessa sala nello stesso periodo.


\subsection{Gestione delle Sale (Room e RoomList)}
Le stanze, trattate come istanze dell'ADT \textbf{Room}, sono gestite all'interno di una struttura dati dinamica denominata \textbf{RoomList}. Questo approccio consente di gestire l'aggiunta, la rimozione e la ricerca delle stanze in modo efficiente. Attraverso questi due moduli, è possibile associare una stanza a un evento; all'interno della rappresentazione di un evento, la stanza è identificata dal suo ID, che viene utilizzato per individuarla all'interno della \textbf{RoomList} e recuperarne le informazioni pertinenti.

\subsection{Gestione degli Eventi (Event e EventBst)}

I singoli eventi sono rappresentati come istanze dell'ADT \textbf{Event} e vengono organizzati all'interno di una struttura gerarchica nota come \textbf{EventBst}, un albero binario di ricerca specializzato. Questo albero consente di gestire l'aggiunta, la ricerca e la rimozione degli eventi in modo relativamente efficiente.

All'atto della creazione di un nuovo evento, quest'ultimo viene inserito nell'albero binario di ricerca, garantendo un ordinamento basato sulla data di inizio dell'evento. In caso di eventi con la stessa data di inizio, l'ordinamento viene effettuato in base al nome dell'evento.

Le operazioni di modifica e rimozione degli eventi vengono eseguite attraverso una ricerca lineare dell'ID dell'evento all'interno dell'albero binario di ricerca. Gli eventi contengono al loro interno un ID che indica la sala a loro assegnata. Nel caso in cui non ci sia una sala assegnata all'evento, questo ID viene impostato al valore \textbf{"NULL\_ROOM\_ID"} definito nel modulo \textbf{Room}.

Ogni evento possiede una data di inizio e fine, rappresentate attraverso istanze dell'ADT \textbf{Date}. La tipologia dell'evento è rappresentata nel modulo attraverso l'enumerazione \textbf{EventType}.


\subsection{Coordinamento della Conferenza (Conference)}
Il modulo \textbf{Conference} funge da coordinatore centrale. Esso mantiene un riferimento all'albero degli eventi (\textbf{EventBst}) e alla lista delle sale (\textbf{RoomList}). Gestisce anche gli inizializzatori degli ID per assegnare identificativi univoci agli eventi e alle sale. Quando un utente interagisce con il sistema per creare, modificare o rimuovere un evento o una sala, il modulo \textbf{Conference} invoca le appropriate funzioni degli altri moduli per eseguire le operazioni richieste. Garantisce quindi che tutti gli eventi e le sale abbiano ID univoci e che non ci siano sovrapposizioni temporali tra due eventi assegnati alla stessa sala. Permette anche di salvare la sessione e leggere da file quelle precedenti.
In questo modulo abbiamo quindi implementato le seguenti operazioni:
\begin{itemize}
    \item \textbf{Aggiunta di un evento}: Vengono chiesti i dati dell'evento all'utente, viene creato l'oggetto Event, assegnandogli un nuovo ID, e viene aggiunto all'albero degli eventi.
    \item \textbf{Rimozione di un evento}: Viene mostrata la lista ordinata degli eventi e si chiede all'utente di inserire l'ID dell'evento che si desidera rimuovere. Viene poi rimosso l'evento dall'albero degli eventi.
    \item \textbf{Modifica di un evento}: Viene mostrata la lista ordinata degli eventi e si chiede all'utente di inserire l'ID dell'evento che si desidera modificare. Viene poi rimosso l'evento selezionato, apportate le modifiche richieste dall'utente e reinserito nell'albero degli eventi.
    \item \textbf{Mostra eventi}: Viene mostrata la lista ordinata degli eventi.
    \item \textbf{Aggiunta di una sala}: Vengono chiesti i dati della sala all'utente, viene creato l'oggetto Room, assegnandogli un nuovo ID, e viene aggiunto alla lista delle sale.
    \item \textbf{Mostra sala}: Viene mostrata la lista delle sale
    \item \textbf{Assegnazione di una sala ad un evento}: Viene mostrata la lista ordinata degli eventi e si chiede all'utente di inserire l'ID dell'evento a cui si desidera assegnare la sala. Viene poi mostrata la lista delle sale e si chiede all'utente di inserire l'ID della sala da assegnare. Viene verifacto poi che non ci siano conflitti con gli orari di altri eventi assegnati alla stessa sala e in caso positivo viene modificato il campo room\_id dell'evento selezionato.
    \item \textbf{Liberare evento da sala}: Viene mostrata la lista ordinata degli eventi e si chiede all'utente di inserire l'ID dell'evento che si desidera liberare. Viene quindi impostato l'ID della sala contenuto nell'evento a "\textbf{NULL\_ROOM\_ID}".

\end{itemize}


\section{Specifiche sintattiche e semantiche}

\subsection{Funzioni e tipi di logging}

\subsubsection{Specificazione del tipo \texttt{LogLevel}}

Definisce un tipo enumerato chiamato \texttt{LogLevel} con i seguenti valori:
\begin{itemize}
	\item \texttt{LOG\_INFO}: Messaggi informativi.
	\item \texttt{LOG\_WARN}: Messaggi di avviso.
	\item \texttt{LOG\_ERROR}: Messaggi di errore.
\end{itemize}

\subsubsection{Specificazione di \texttt{set\_log\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{set\_log\_file(FILE*)}
	\item tipi: \texttt{FILE*}
	\item tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{set\_log\_file(file)}
	\item Imposta il file di log al file specificato.
	\item Precondizioni: \texttt{file} è un puntatore \texttt{FILE} valido aperto in modalità scrittura.
	\item Postcondizioni: Le funzioni di log scriveranno nel file specificato. Se \texttt{file} è \texttt{NULL}, le funzioni di log non scriveranno in nessun file.
\end{itemize}



\subsubsection{Specificazione di \texttt{log\_message(LogLevel,  char*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{log\_message(LogLevel,  char*)}
	\item tipi: \texttt{LogLevel}, \texttt{ char*}
	\item tipi interni: \texttt{time\_t}, \texttt{struct tm}, \texttt{char[]}, \texttt{FILE*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{log\_message(level, message)}
	\item Registra un messaggio con il livello di log specificato.
	\item Precondizioni:
	      \begin{itemize}
		      \item \texttt{level} è uno tra \texttt{LOG\_INFO}, \texttt{LOG\_WARN}, \texttt{LOG\_ERROR}.
		      \item \texttt{message} è un puntatore non nullo a una stringa terminata da null.
		      \item Il file di log è stato impostato usando \texttt{set\_log\_file}.
	      \end{itemize}
	\item Postcondizioni:
	      \begin{itemize}
		      \item Il messaggio è scritto nel file di log con un prefisso che include timestamp e livello di log.
		      \item Se il file di log non è impostato, non sarà generato alcun output.
	      \end{itemize}
\end{itemize}

\subsubsection{Specificazione di \texttt{log\_error( char*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{log\_error( char*)}
	\item tipi: \texttt{ char*}
	\item tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{log\_error(message)}
	\item Registra un messaggio di errore.
	\item Precondizioni:
	      \begin{itemize}
		      \item \texttt{message} è un puntatore non nullo a una stringa.
		      \item Il file di log è stato impostato usando \texttt{set\_log\_file}.
	      \end{itemize}
	\item Postcondizioni:
	      \begin{itemize}
		      \item Il messaggio di errore è scritto nel file di log con un prefisso che include timestamp e la dicitura "ERROR".
		      \item Se il file di log non è impostato, non sarà generato alcun output.
	      \end{itemize}
\end{itemize}

\subsection{Funzioni e tipi di utilità}

\subsubsection{Specificazione del tipo \texttt{ResultInt}}


\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: ResultInt
	\item Tipi utilizzati: int
	\item Campi:
	      \begin{itemize}
		      \item error\_code: Codice di errore: 0 per successo, valori negativi per gli errori.
		      \item value: Valore intero risultante.
	      \end{itemize}
\end{itemize}



\textbf{Specificazione Semantica:} \\
Rappresenta il valore intero di ritorno di un'operazione che potrebbe fallire.

\subsubsection{Funzione \texttt{clean\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{clean\_file(FILE*)}
	\item Tipi: \texttt{FILE*}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{clean\_file(file)}
	\item Scarta i caratteri dal flusso del file fino a raggiungere una nuova riga o la fine del file.
	\item Precondizioni: 'file' è un puntatore FILE valido aperto in modalità lettura.
	\item Postcondizioni: Il puntatore del file viene avanzato oltre i caratteri scartati.
\end{itemize}

\subsubsection{Funzione \texttt{int read\_line\_from\_file(char*, int, FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_line\_from\_file(char*, int, FILE*) -> int}
	\item Tipi: \texttt{char*, int, FILE*}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_line\_from\_file(line, size, file) -> res}
	\item  Legge una riga dal file specificato nel buffer, assicurandosi che ci sia spazio per essa e  gestendo eventuali errori.
	\item Precondizioni: 'line' è un buffer valido di dimensione 'size'. 'file' è un puntatore FILE valido aperto in modalità lettura.
	\item Postcondizioni: In caso di successo, la riga viene memorizzata in 'line' senza il carattere di nuova riga. In caso di fallimento, restituisce -1 se viene raggiunta la fine del file, -2 se la riga è troppo lunga e -3 se si verifica un errore di lettura.
\end{itemize}

\subsubsection{Funzione \texttt{int read\_line(char*, int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_line(char*, int) -> int}
	\item Tipi: \texttt{char*, int}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_line(line, size) -> res}
	\item Legge una riga dallo standard input nel buffer.
	\item Precondizioni: 'line' è un buffer valido di dimensione 'size'.
	\item Postcondizioni: In caso di successo, la riga viene memorizzata in 'line' senza il carattere di nuova riga. In caso di errore, restituisce -1 se si raggiunge la fine del file, -2 se la riga è troppo lunga e -3 se si verifica un errore di lettura.
\end{itemize}

\subsubsection{Funzione \texttt{ResultInt read\_int(void)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_int(void) -> ResultInt}
	\item Tipi: \texttt{ResultInt}
	\item Tipi interni: \texttt{int}, \texttt{char[]}, \texttt{char*}, \texttt{long}, \texttt{errno\_t}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_int() -> res}
	\item Legge un intero dallo standard input e gestisce gli errori.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: In caso di successo, restituisce un \texttt{ResultInt} con il valore dell'intero e \texttt{error\_code} pari a 0. In caso di errore, \texttt{error\_code} viene impostato a -1 per errori di lettura, -2 per errori di intervallo e -3 per input non valido.
\end{itemize}

\subsubsection{Funzione \texttt{my\_alloc(unsigned long, unsigned long)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{my\_alloc(unsigned long, unsigned long)}
	\item Tipi: \texttt{unsigned long}
	\item Tipi interni: \texttt{void*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{my\_alloc(nmemb, size)}
	\item Alloca memoria per un array di 'nmemb' elementi, ciascuno di dimensione 'size' byte e inizializza tutti i byte a zero.
	\item Precondizioni: 'nmemb' e 'size' devono essere diversi da zero.
	\item Postcondizioni: In caso di successo, restituisce un puntatore alla memoria allocata. In caso di errore, registra un errore e termina il programma.
\end{itemize}

\subsubsection{Funzione \texttt{my\_realloc(void*, unsigned long, unsigned long)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{my\_realloc(void*, unsigned long, unsigned long)}
	\item Tipi: \texttt{void*}, \texttt{unsigned long}
	\item Tipi interni: \texttt{void*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{my\_realloc(p, nmemb, size)}
	\item Rialloca la memoria per un array di 'nmemb' elementi, ciascuno di dimensione 'size' byte.
	\item Precondizioni: 'p' è un puntatore a un blocco di memoria precedentemente allocato dinamicamente o NULL. 'nmemb' e 'size' devono essere diversi da zero.
	\item Postcondizioni: In caso di successo, restituisce un puntatore alla memoria riallocata. In caso di errore, registra un errore e termina il programma.
\end{itemize}

\subsubsection{Funzione \texttt{char* my\_strdup( char*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{my\_strdup( char*) -> char*}
	\item Tipi: \texttt{char*}
	\item Tipi interni: \texttt{char*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{my\_strdup(string) -> res\_string}
	\item Duplica la stringa data.
	\item Precondizioni: 'string' è una stringa valida terminata da '\textbackslash0'.
	\item Postcondizioni: In caso di successo, restituisce un puntatore alla stringa duplicata. In caso di errore, registra un errore e termina il programma.
\end{itemize}

\subsubsection{Funzione \texttt{trim\_whitespaces(char*, char*, int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{trim\_whitespaces(char*, char*, int)}
	\item Tipi: \texttt{char*}, \texttt{char*}, \texttt{int}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{trim\_whitespaces(dest, src, max\_size)}
	\item Rimuove gli spazi vuoti iniziali e finali dalla stringa di origine 'src' e la copia nel buffer di destinazione 'dest'.
	\item Precondizioni: 'dest' e 'src' sono puntatori validi, 'max\_size' è la dimensione di 'dest'.
	\item Postcondizioni: 'dest' contiene la stringa senza spazi vuoti. Se 'max\_size' è 0, la funzione non fa nulla.
\end{itemize}

\subsection{Specifica dell'ADT Date}


\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: Date
	\item Tipi utilizzati: unsigned char, unsigned short
\end{itemize}

\textbf{Specificazione Semantica:} \\
Date rappresenta una data valida con precisione al minuto. \\

\textbf{Operatori:}
\begin{itemize}
    \item \texttt{new\_date(unsigned int, unsigned int, unsigned int) -> Date}
    \item \texttt{copy\_date(Date) -> Date}
    \item \texttt{cmp\_date(Date, Date) -> int}
    \item \texttt{save\_date\_to\_file(Date, FILE*) -> void}
    \item \texttt{read\_date\_from\_file(FILE*) -> Date}
    \item \texttt{print\_date(Date) -> void}
    \item \texttt{read\_date(unsigned int) -> Date}
    \item \texttt{free\_date(Date) -> void}
\end{itemize}




\subsubsection{Funzione \texttt{Date new\_date(unsigned char, unsigned char, unsigned char, unsigned char, unsigned short) }}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{new\_date(unsigned char, unsigned char, unsigned char, unsigned char, unsigned short) -> Date}
	\item Tipi: \texttt{unsigned char}, \texttt{unsigned short}
	\item Tipi interni: \texttt{Date}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{new\_date(minutes, hour, day, month, year) -> return\_date}
	\item Crea un nuovo oggetto \texttt{Date} con i componenti specificati.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} creato o NULL se la data non è valida. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione \texttt{Date copy\_date(Date)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{copy\_date(Date) -> Date}
	\item Tipi: \texttt{Date}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{copy\_date(date) -> return\_date}
	\item Crea una copia dell'oggetto \texttt{Date} fornito.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} creato, che è una copia di 'date'. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione \texttt{int cmp\_date(Date, Date) }}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{cmp\_date(Date, Date) -> int}
	\item Tipi: \texttt{Date}
	\item Tipi interni: \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item Confronta due oggetti \texttt{Date}.
	\item Precondizioni: 'date\_a' e 'date\_b' sono oggetti \texttt{Date} validi.
	\item Postcondizioni: Restituisce un intero minore di zero, uguale a zero o maggiore di zero se 'date\_a' è rispettivamente inferiore, uguale o superiore a 'date\_b'.
\end{itemize}

\subsubsection{Funzione \texttt{save\_date\_to\_file(Date, FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{save\_date\_to\_file(Date, FILE*)}
	\item Tipi: \texttt{Date}, \texttt{FILE*}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{save\_date\_to\_file(date, file)}
	\item Salva l'oggetto \texttt{Date} fornito in 'file'.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido. 'file' è un file valido aperto in scrittura.
	\item Postcondizioni: I componenti di 'date' vengono scritti nel file 'file'.
\end{itemize}

\subsubsection{Funzione \texttt{Date read\_date\_from\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_date\_from\_file(FILE*) -> Date}
	\item Tipi: \texttt{FILE*}
	\item Tipi interni: \texttt{Date}, \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_date\_from\_file(file) -> return\_date}
	\item Legge un oggetto \texttt{Date} da un file.
	\item Precondizioni: 'file' è un file valido.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} letto dal file 'file', o NULL se la lettura fallisce. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione \texttt{print\_date(Date)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{print\_date(Date)}
	\item Tipi: \texttt{Date}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{print\_date(date)}
	\item Stampa i componenti dell'oggetto \texttt{Date} su stdout in un formato leggibile dall'utente.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido.
	\item Postcondizioni: I componenti di 'date' vengono stampati su stdout in un formato comprensibile.
\end{itemize}

\subsubsection{Funzione: \texttt{Date read\_date(void)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_date(void) -> Date}
	\item Tipi: Nessuno
	\item Tipi interni: \texttt{Date}, \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_date() -> return\_date}
	\item Legge un oggetto \texttt{Date} dall'input standard.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} letto dall'input standard (stdin), o NULL se la lettura fallisce. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione: \texttt{free\_date(Date)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{free\_date(Date)}
	\item Tipi: \texttt{Date}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{free\_date(date)}
	\item Libera la memoria allocata per un oggetto \texttt{Date}.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido.
	\item Postcondizioni: La memoria allocata per 'date' viene deallocata.
\end{itemize}

\subsection{Specifica dell'ADT Room}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: Room
	\item Tipi utilizzati: unsigned int, char*
\end{itemize}
\textbf{Specificazione Semantica:} \\
Room rappresenta una sala della conferenza.\\

\textbf{Operatori:} \\
\begin{itemize}
    \item \texttt{new\_room(char*, unsigned int, unsigned int) -> Room}
    \item \texttt{copy\_room(Room) -> Room}
    \item \texttt{are\_rooms\_equal(Room, Room) -> bool}
    \item \texttt{get\_room\_name(Room) ->  char*}
    \item \texttt{get\_room\_id(Room) -> unsigned int}
    \item \texttt{print\_room(Room) -> void}
    \item \texttt{read\_room(unsigned int) -> Room}
    \item \texttt{save\_room\_to\_file(Room, FILE*) -> void}
    \item \texttt{read\_room\_from\_file(FILE*) -> Room}
    \item \texttt{free\_room(Room) -> void}
\end{itemize}



\subsubsection{Funzione: \texttt{Room new\_room( char*, unsigned int, unsigned int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{new\_room( char* name, unsigned int id, unsigned int capacity) -> Room}
	\item Tipi: \texttt{ char *}, \texttt{unsigned int}
	\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{new\_room(name, id, capacity) -> return\_room}
	\item Crea un nuovo oggetto \texttt{Room} con il nome, l'ID e la capacità specificati.
	\item Precondizioni: 'name' è una stringa valida che rappresenta il nome della stanza. 'id' è un intero non negativo che rappresenta l'ID della stanza. 'capacity' è un intero non negativo che rappresenta la capacità della stanza.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Room} creato, o NULL se si verifica un errore. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{Room copy\_room(Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{copy\_room(Room room) -> Room}
	\item Tipi: \texttt{Room}
	\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{copy\_room(room) -> return\_room}
	\item Crea una copia dell'oggetto \texttt{Room} fornito.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: Restituisce un puntatore alla copia appena creata di \texttt{room}. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{bool are\_rooms\_equal(Room, Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{are\_rooms\_equal(Room room\_a, Room room\_b) -> bool}
	\item Tipi: \texttt{Room}, \texttt{bool}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{are\_rooms\_equal(room\_a, room\_b) -> result}
	\item Verifica se due oggetti \texttt{Room} sono uguali in base ai loro ID.
	\item Precondizioni: I parametri di input \texttt{room\_a} e \texttt{room\_b} sono oggetti \texttt{Room} validi.
	\item Postcondizioni: Restituisce true se \texttt{room\_a} e \texttt{room\_b} hanno lo stesso ID, altrimenti false.
\end{itemize}

\subsubsection{Funzione: \texttt{ char* get\_room\_name(Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{get\_room\_name(Room room) ->  char*}
	\item Tipi: \texttt{Room}, \texttt{ char *}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{get\_room\_name(room) -> name}
	\item Ottiene il nome dell'oggetto \texttt{Room} fornito.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: Restituisce un puntatore al nome di \texttt{room}.
\end{itemize}

\subsubsection{Funzione: \texttt{unsigned int get\_room\_id(Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{get\_room\_id(Room room) -> unsigned int}
	\item Tipi: \texttt{Room}, \texttt{unsigned int}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{get\_room\_id(room) -> id}
	\item Ottiene l'ID dell'oggetto \texttt{Room} fornito.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: Restituisce l'ID di \texttt{room}.
\end{itemize}

\subsubsection{Funzione: \texttt{print\_room(Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{print\_room(Room room) -> void}
	\item Tipi: \texttt{Room}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{print\_room(room)}
	\item Stampa i dettagli dell'oggetto \texttt{Room} fornito su stdout.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: I dettagli di \texttt{room} sono stampati su stdout.
\end{itemize}

\subsubsection{Funzione: \texttt{Room read\_room(unsigned int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_room(unsigned int id) -> Room}
	\item Tipi: \texttt{unsigned int}, \texttt{Room}
	\item Tipo interno: \texttt{char[]}, \texttt{ResultInt}, \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_room(id) -> room}
	\item Legge i dettagli di un oggetto \texttt{Room} da stdin e crea un nuovo oggetto \texttt{Room} con id 'id'.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Room} creato, o NULL se si verifica un errore. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{save\_room\_to\_file(Room, FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{save\_room\_to\_file(Room room, FILE* file)}
	\item Tipi: \texttt{Room} , \texttt{FILE*}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{save\_room\_to\_file(room, file)}
	\item Salva i dettagli dell'oggetto \texttt{Room} fornito su un file.
	\item Precondizioni: 'room' è un oggetto \texttt{Room} valido. 'file' è un file valido aperto in scrittura.
	\item Postcondizioni: I dettagli di \texttt{room} sono scritti sul file 'file'.
\end{itemize}

\subsubsection{Funzione: \texttt{Room read\_room\_from\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_room\_from\_file(FILE* file) -> Room}
	\item Tipi: \texttt{FILE*}, \texttt{Room}
	\item Tipo interno: \texttt{char[]}, \texttt{unsigned int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_room\_from\_file(file) -> room}
	\item Legge i dettagli di un oggetto \texttt{Room} da un file e crea un nuovo oggetto \texttt{Room}.
	\item Precondizioni: 'file' è un file valido aperto in lettura.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Room} creato, o NULL se si verifica un errore. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{free\_room(Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{free\_room(Room room)}
	\item Tipi: \texttt{Room}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{free\_room(room)}
	\item Libera la memoria allocata per un oggetto \texttt{Room}.
	\item Precondizioni: 'room' è un oggetto \texttt{Room} valido.
	\item Postcondizioni: La memoria allocata per 'room' viene deallocata.
\end{itemize}

\subsection{Specifica dell'ADT Event}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: Event
	\item Tipi utilizzati: unsigned int, char*, Date, EventType (intero da 0 a 2)
\end{itemize}
\textbf{Specificazione Semantica:} \\
Event rappresenta un evento della conferenza.\\

\textbf{Operatori:}:
\begin{itemize}
\item \texttt{new\_event(EventType,  char *, Date, Date, unsigned int) -> Event}
\item \texttt{are\_events\_equal(Event, Event) -> int}
\item \texttt{cmp\_event(Event, Event) -> int}
\item \texttt{do\_events\_overlap(Event, Event) -> bool}
\item \texttt{get\_event\_type(Event) -> EventType}
\item \texttt{set\_event\_type(Event, EventType) -> int}
\item \texttt{get\_event\_start\_date(Event) -> Date}
\item \texttt{set\_event\_start\_date(Event, Date) -> int}
\item \texttt{get\_event\_end\_date(Event) -> Date}
\item \texttt{set\_event\_end\_date(Event, Date) -> int}
\item \texttt{get\_event\_name(Event) ->  char *}
\item \texttt{set\_event\_name(Event,  char *) -> int}
\item \texttt{get\_event\_room\_id(Event) -> unsigned int}
\item \texttt{set\_event\_room\_id(Event, unsigned int) -> int}
\item \texttt{get\_event\_id(Event) -> unsigned int}
\item \texttt{print\_event(Event, Room) -> void}
\item \texttt{read\_event(unsigned int) -> Event}
\item \texttt{save\_event\_to\_file(Event, FILE *) -> void}
\item \texttt{read\_event\_from\_file(FILE *) -> Event}
\item \texttt{free\_event(Event) -> void}
\end{itemize}



\subsubsection{Funzione: \texttt{is\_valid\_event\_type(int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{is\_valid\_event\_type(int type) -> int}
\item Tipi: \texttt{int}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{is\_valid\_event\_type(type) -> result}
\item Verifica se il tipo evento fornito è valido.
\item Precondizioni: Nessuna.
\item Postcondizioni: Restituisce 1 se il tipo evento è valido, 0 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{Event new\_event(EventType,  char *, Date, Date, unsigned int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{new\_event(EventType type,  char *name, Date start\_date, Date end\_date, unsigned int id) -> Event}
\item Tipi: \texttt{EventType}, \texttt{ char *}, \texttt{Date}, \texttt{unsigned int}
\item Tipo interno: \texttt{Event}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{new\_event(type, name, start\_date, end\_date, id) -> event}
\item Crea un nuovo evento con il tipo, nome, data di inizio, data di fine e ID specificati.
\item Precondizioni: Nessuna.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Event} creato.
\end{itemize}

\subsubsection{Funzione: \texttt{int are\_events\_equal(Event, Event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{are\_events\_equal(Event event\_a, Event event\_b) -> int}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{are\_events\_equal(event\_a, event\_b) -> result}
\item Verifica se due eventi sono uguali in base ai loro ID.
\item Precondizioni: event\_a e event\_b sono due oggeti Event validi..
\item Postcondizioni: Restituisce 1 se gli eventi sono uguali, 0 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{int cmp\_event(Event, Event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{cmp\_event(Event event\_a, Event event\_b) -> int}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{cmp\_event(event\_a, event\_b) -> result}
\item Confronta due eventi per l'ordinamento basato sulla data di inizio e sul nome.
\item Precondizioni: event\_a e event\_b sono due oggeti Event validi.
\item Postcondizioni: Restituisce un valore negativo se \texttt{event\_a} viene prima di \texttt{event\_b}, un valore positivo se \texttt{event\_a} viene dopo \texttt{event\_b}, e 0 se sono uguali.
\end{itemize}

\subsubsection{Funzione: \texttt{bool do\_events\_overlap(Event, Event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{do\_events\_overlap(Event event\_a, Event event\_b) -> bool}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{do\_events\_overlap(event\_a, event\_b) -> result}
\item Verifica se due eventi si sovrappongono nel tempo.
\item Precondizioni: event\_a e event\_b sono due oggeti Event validi.
\item Postcondizioni: Restituisce vero se gli eventi si sovrappongono, falso altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{EventType get\_event\_type(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_event\_type(Event event) -> EventType}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_event\_type(event) -> type}
\item Recupera il tipo dell'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce il tipo di evento (\texttt{EventType}).
\end{itemize}

\subsubsection{Funzione: \texttt{int set\_event\_type(Event event, EventType type)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{set\_event\_type(Event event, EventType type) -> int}
\item Tipi: \texttt{Event}, \texttt{EventType}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{set\_event\_type(event, type) -> result}
\item Imposta il tipo dell'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce 0 se l'operazione ha avuto successo, -1 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{Date get\_event\_start\_date(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_event\_start\_date(Event event) -> Date}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_event\_start\_date(event) -> start\_date}
\item Recupera la data di inizio dell'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce un puntatore all'oggetto Data di inizio dell'evento.
\end{itemize}

\subsubsection{Funzione: \texttt{int set\_event\_start\_date(Event event, Date start\_date)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{set\_event\_start\_date(Event event, Date start\_date) -> int}
\item Tipi: \texttt{Event}, \texttt{Date}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{set\_event\_start\_date(event, start\_date) -> result}
\item Imposta la data di inizio dell'evento.
\item Precondizioni: event è un oggetto Event valido, start date è un oggetto date valido.
\item Postcondizioni: Restituisce 0 se l'operazione ha avuto successo, -1 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{Date get\_event\_end\_date(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_event\_end\_date(Event event) -> Date}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_event\_end\_date(event) -> end\_date}
\item Recupera la data di fine dell'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce un puntatore all'oggetto Data di fine dell'evento.
\end{itemize}

\subsubsection{Funzione: \texttt{int set\_event\_end\_date(Event event, Date end\_date)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{set\_event\_end\_date(Event event, Date end\_date) -> int}
\item Tipi: \texttt{Event}, \texttt{Date}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{set\_event\_end\_date(event, end\_date) -> result}
\item Imposta la data di fine dell'evento.
\item Precondizioni: event è un oggetto Event valido, end date è un oggetto date valido.
\item Postcondizioni: Restituisce 0 se l'operazione ha avuto successo, -1 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{ char *get\_event\_name(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_event\_name(Event event) ->  char *}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_event\_name(event) -> name}
\item Restituisce il nome dell'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce un puntatore alla stringa del nome dell'evento.
\end{itemize}

\subsubsection{Funzione: \texttt{int set\_event\_name(Event event,  char *name)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{set\_event\_name(Event event,  char *name) -> int}
\item Tipi: \texttt{Event}, \texttt{ char *}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{set\_event\_name(event, name) -> result}
\item Imposta il nome dell'evento.
\item Precondizioni: event è un oggetto Event valido, name è una stringa valida.
\item Postcondizioni: Restituisce 0 se l'operazione ha avuto successo, -1 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{unsigned int get\_event\_room\_id(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_event\_room\_id(Event event) -> unsigned int}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_event\_room\_id(event) -> room\_id}
\item Restituisce l'ID della stanza assegnata all'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce l'ID della stanza dell'evento.
\end{itemize}

\subsubsection{Funzione: \texttt{int set\_event\_room\_id(Event event, unsigned int room\_id)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{set\_event\_room\_id(Event event, unsigned int room\_id) -> int}
\item Tipi: \texttt{Event}, \texttt{unsigned int}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{set\_event\_room\_id(event, room\_id) -> result}
\item Imposta l'ID della stanza assegnata all'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce 0 se l'operazione ha avuto successo, -1 altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{unsigned int get\_event\_id(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_event\_id(Event event) -> unsigned int}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_event\_id(event) -> id}
\item Restituisci l'ID dell'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce l'ID dell'evento.
\end{itemize}

\subsubsection{Funzione: \texttt{print\_event(Event event, Room assigned\_room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{print\_event(Event event, Room assigned\_room) -> void}
\item Tipi: \texttt{Event}, \texttt{Room}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{print\_event(event, assigned\_room)}
\item Stampa i dettagli dell'evento su stdout, inclusa l'informazione sulla stanza assegnata se disponibile.
\item Precondizioni: Nessuna.
\item Postcondizioni: Nessuna.
\end{itemize}

\subsubsection{Funzione: \texttt{Event read\_event(unsigned int event\_id)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{read\_event(unsigned int event\_id) -> Event}
\item Tipi: \texttt{unsigned int}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{read\_event(event\_id) -> event}
\item Legge i dettagli dell'evento dall'input dell'utente.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto Event creato.
\end{itemize}

\subsubsection{Funzione: \texttt{save\_event\_to\_file(Event event, FILE *file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{save\_event\_to\_file(Event event, FILE *file) -> void}
\item Tipi: \texttt{Event}, \texttt{FILE}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{save\_event\_to\_file(event, file)}
\item Salva i dettagli dell'evento su un file.
\item Precondizioni: event è un oggetto Event valido, il file è aperto in scrittura.
\item Postcondizioni: Nessuna.
\end{itemize}

\subsubsection{Funzione: \texttt{Event read\_event\_from\_file(FILE *file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{read\_event\_from\_file(FILE *file) -> Event}
\item Tipi: \texttt{FILE}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{read\_event\_from\_file(file) -> event}
\item Legge i dettagli dell'evento da un file.
\item Precondizioni: event è un oggetto Event valido, il file è aperto in lettura.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto Event creato.
\end{itemize}

\subsubsection{Funzione: \texttt{free\_event(Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{free\_event(Event event) -> void}
\item Tipi: \texttt{Event}
\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{free\_event(event)}
\item Libera la memoria allocata per l'evento.
\item Precondizioni: event è un oggetto Event valido.
\item Postcondizioni: La memoria allocate per event viene deallocata.
\end{itemize}


\subsection{Specifica dell'ADT EventBst}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: EventBst
	\item Tipi utilizzati: Event
\end{itemize}
\textbf{Specificazione Semantica:} \\
EventBst rappresenta un albero binario di ricerca di oggetti di tipo Event\\

\textbf{Operatori:}
\begin{itemize}
    \item \texttt{new\_event\_bst(void) -> EventBst}
    \item \texttt{bst\_insert\_event(EventBst bst, Event event) -> int}
    \item \texttt{bst\_remove\_event(EventBst bst, Event event) -> Event}
    \item \texttt{bst\_remove\_event\_by\_id(EventBst bst, unsigned int id) -> Event}
    \item \texttt{bst\_get\_event\_by\_id(EventBst bst, unsigned int id) -> Event}
    \item \texttt{get\_bst\_size(EventBst bst) -> size\_t}
    \item \texttt{print\_event\_bst(EventBst bst, RoomList room\_list) -> void}
    \item \texttt{event\_bst\_every(EventBst bst, EventPredicate predicate, ...) -> bool}
    \item \texttt{read\_event\_bst\_from\_file(FILE* file) -> EventBst}
    \item \texttt{save\_event\_bst\_to\_file(EventBst bst, FILE* file) -> void}
    \item \texttt{save\_event\_bst\_to\_file\_sorted(EventBst bst, FILE* file) -> void}
    \item \texttt{free\_event\_bst(EventBst bst) -> void}
\end{itemize}


\subsubsection{Funzione: \texttt{EventBst new\_event\_bst}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{new\_event\_bst(void) -> EventBst}
\item Tipi: Nessuno
\item Tipi interni: \texttt{EventBst}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{new\_event\_bst() -> bst}
\item Crea un nuovo albero di ricerca binario (BST) vuoto per memorizzare eventi.
\item Precondizioni: Nessuna.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{EventBst} vuoto.
\end{itemize}

\subsubsection{Funzione: \texttt{int bst\_insert\_event(EventBst bst, Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{bst\_insert\_event(EventBst, Event) -> int}
\item Tipi: \texttt{EventBst, Event}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{bst\_insert\_event(bst, event) -> result}
\item Inserisce un evento nell'albero di ricerca binario (BST).
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido. \texttt{event} deve puntare a un oggetto \texttt{Event} valido.
\item Postcondizioni: Se l'operazione ha successo, l'evento viene inserito nel BST. Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{Event bst\_remove\_event(EventBst bst, Event event)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{bst\_remove\_event(EventBst, Event) -> Event}
\item Tipi: \texttt{EventBst, Event}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{bst\_remove\_event(bst, event) -> removed\_event}
\item Rimuove l'evento specificato dall'albero di ricerca binario (BST).
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido. \texttt{event} deve puntare a un oggetto \texttt{Event} valido.
\item Postcondizioni: Se l'operazione ha successo, l'evento viene rimosso dal BST. Restituisce l'oggetto Event rimosso, o NULL\_EVENT se l'evento non è stato trovato.
\end{itemize}

\subsubsection{Funzione: \texttt{Event bst\_remove\_event\_by\_id(EventBst bst, unsigned int id)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{bst\_remove\_event\_by\_id(EventBst, unsigned int) -> Event}
\item Tipi: \texttt{EventBst, unsigned int}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{bst\_remove\_event\_by\_id(bst, id) -> removed\_event}
\item Rimuove l'evento con l'ID specificato dall'albero di ricerca binario (BST).
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido.
\item Postcondizioni: Se l'operazione ha successo, l'evento con l'ID specificato viene rimosso dal BST. Restituisce l'oggetto Event rimosso, o NULL\_EVENT se l'evento non è stato trovato.
\end{itemize}

\subsubsection{Funzione: \texttt{Event bst\_get\_event\_by\_id(EventBst bst, unsigned int id)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{bst\_get\_event\_by\_id(EventBst, unsigned int) -> Event}
\item Tipi: \texttt{EventBst, unsigned int}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{bst\_get\_event\_by\_id(bst, id) -> event}
\item Recupera l'evento con l'ID specificato dall'albero di ricerca binario (BST).
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido.
\item Postcondizioni: Restituisce l'oggetto Event con l'ID specificato, o NULL\_EVENT se l'evento non è stato trovato.
\end{itemize}

\subsubsection{Funzione: \texttt{size\_t get\_bst\_size(EventBst bst)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_bst\_size(EventBst) -> size\_t}
\item Tipi: \texttt{EventBst}
\item Tipi interni: \texttt{Nessuna}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_bst\_size(bst) -> size}
\item Restituisce il numero di eventi memorizzati nell'albero di ricerca binario (BST).
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido.
\item Postcondizioni: Restituisce il numero di eventi memorizzati nel BST.
\end{itemize}

\subsubsection{Funzione: \texttt{bool print\_event\_bst(EventBst bst, RoomList room\_list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{print\_event\_bst(EventBst, RoomList) -> void}
\item Tipi: \texttt{EventBst, RoomList}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{print\_event\_bst(bst, room\_list)}
\item Stampa in ordine gli eventi memorizzati nell'albero di ricerca binario (BST) insieme alle stanze assegnate.
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido. \texttt{room\_list} deve puntare a un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Stampa gli eventi e le stanze assegnate all'output standard.
\end{itemize}

\subsubsection{Funzione: \texttt{bool event\_bst\_every(EventBst, EventPredicate, ...)}}

\textbf{Specificazione Sintattica}
\begin{itemize}
\item \texttt{event\_bst\_every(EventBst, EventPredicate, ...) -> bool}
\item Tipi: \texttt{EventBst, EventPredicate}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{event\_bst\_every(bst, predicate, ...)}
\item Verifica se un dato predicato è vero per ogni evento nell'albero di ricerca binario (BST).
\item Precondizione : \texttt{bst} deve puntare a un oggetto valido di tipo \texttt{EventBst}.
\texttt{predicate} deve essere un puntatore valido a una funzione predicato che prende un Evento e argomenti variabili (copie degli ulteriori argomenti passati alla funzione \texttt{event\_bst\_every}).
\item Postcondizioni: Restituisce \texttt{true} se il predicato è vero per ogni evento nel BST, \texttt{false} altrimenti.
\end{itemize}


\subsubsection{Funzione: \texttt{EventBst read\_event\_bst\_from\_file(FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{read\_event\_bst\_from\_file(FILE*) -> EventBst}
\item Tipi: \texttt{FILE*}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{read\_event\_bst\_from\_file(file) -> bst}
\item Legge i dati degli eventi da un file e costruisce un albero di ricerca binario (BST) per memorizzare gli eventi.
\item Precondizioni: \texttt{file} deve puntare a un oggetto \texttt{FILE} valido aperto in lettura.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto
\texttt{EventBst} contenente gli eventi letti dal file.
\end{itemize}

\subsubsection{Funzione: \texttt{void save\_event\_bst\_to\_file(EventBst bst, FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{save\_event\_bst\_to\_file(EventBst, FILE*) -> void}
\item Tipi: \texttt{EventBst, FILE*}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{save\_event\_bst\_to\_file(bst, file)}
\item Salva gli eventi memorizzati nell'albero di ricerca binario (BST) su un file.
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido. \texttt{file} deve puntare a un oggetto \texttt{FILE} valido aperto in modalità scrittura.
\item Postcondizioni: Scrive gli eventi memorizzati nel BST sul file specificato.
\end{itemize}

\subsubsection{Funzione: \texttt{void save\_event\_bst\_to\_file\_sorted(EventBst bst, FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{save\_event\_bst\_to\_file\_sorted(EventBst, FILE*) -> void}
\item Tipi: \texttt{EventBst, FILE*}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{save\_event\_bst\_to\_file\_sorted(bst, file)}
\item Salva gli eventi memorizzati nell'albero di ricerca binario (BST) su un file in ordine ordinato.
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido. \texttt{file} deve puntare a un oggetto \texttt{FILE} valido aperto in modalità scrittura.
\item Postcondizioni: Scrive gli eventi memorizzati nel BST sul file specificato in ordine ordinato.
\end{itemize}

\subsubsection{Funzione: \texttt{void free\_event\_bst(EventBst bst)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{free\_event\_bst(EventBst) -> void}
\item Tipi: \texttt{EventBst}
\item Tipi interni: \texttt{EventBstNode}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{free\_event\_bst(bst)}
\item Libera la memoria allocata per l'albero di ricerca binario (BST) e i suoi nodi.
\item Precondizioni: \texttt{bst} deve puntare a un oggetto \texttt{EventBst} valido.
\item Postcondizioni: Libera la memoria allocata per il BST e i suoi nodi.
\end{itemize}

\subsection{Specifica dell'ADT RoomList}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: RoomList
	\item Tipi utilizzati: int, Room
\end{itemize}
\textbf{Specificazione Semantica:} \\
RoomList rappresenta una sequenza di oggetti di tipo Room\\

\textbf{Operazioni:}
\begin{itemize}
    \item \texttt{new\_room\_list(void) -> RoomList}
    \item \texttt{is\_room\_list\_empty(RoomList list) -> bool}
    \item \texttt{get\_size\_room\_list(RoomList list) -> int}
    \item \texttt{cons\_room\_list(RoomList list, Room room) -> void}
    \item \texttt{tail\_room\_list(RoomList list) -> Room}
    \item \texttt{get\_first\_room\_list(RoomList list) -> Room}
    \item \texttt{get\_at\_room\_list(RoomList list, int pos) -> Room}
    \item \texttt{get\_room\_by\_id(RoomList list, unsigned int room\_id) -> Room}
    \item \texttt{remove\_at\_room\_list(RoomList list, int pos) -> Room}
    \item \texttt{get\_pos\_room\_list(RoomList list, Room to\_search) -> int}
    \item \texttt{print\_room\_list(RoomList list) -> void}
    \item \texttt{save\_room\_list\_to\_file(RoomList list, FILE* file) -> void}
    \item \texttt{read\_room\_list\_from\_file(FILE* file) -> RoomList}
    \item \texttt{free\_room\_list(RoomList list) -> void}
\end{itemize}


\subsubsection{Funzione: \texttt{RoomList new\_room\_list(void)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{new\_room\_list(void) -> RoomList}
\item Tipi: Nessuno
\item Tipi interni: \texttt{RoomList}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{new\_room\_list() -> list}
\item Crea una nuova lista vuota di stanze.
\item Precondizioni: Nessuna.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{RoomList} vuoto creato.
\end{itemize}

\subsubsection{Funzione: \texttt{bool is\_room\_list\_empty(RoomList list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{is\_room\_list\_empty(RoomList) -> bool}
\item Tipi: \texttt{RoomList}
\item Tipi interni: \texttt{bool}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{is\_room\_list\_empty(list) -> empty}
\item Verifica se la lista delle stanze è vuota.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Restituisce true se la lista è vuota, false altrimenti.
\end{itemize}

\subsubsection{Funzione: \texttt{int get\_size\_room\_list(RoomList list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_size\_room\_list(RoomList) -> int}
\item Tipi: \texttt{RoomList}
\item Tipi interni: \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_size\_room\_list(list) -> size}
\item Ottiene il numero di stanze nella lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Restituisce il numero di stanze nella lista.
\end{itemize}

\subsubsection{Funzione: \texttt{void cons\_room\_list(RoomList list, Room room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{cons\_room\_list(RoomList, Room) -> void}
\item Tipi: \texttt{RoomList, Room}
\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{cons\_room\_list(list, room)}
\item Aggiunge una stanza all'inizio della lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido, \texttt{room} è un oggetto \texttt{Room} valido.
\item Postcondizioni: La stanza viene aggiunta all'inizio della lista.
\end{itemize}

\subsubsection{Funzione: \texttt{Room tail\_room\_list(RoomList list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{tail\_room\_list(RoomList) -> Room}
\item Tipi: \texttt{RoomList}
\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{tail\_room\_list(list) -> room}
\item Rimuove e restituisce l'ultima stanza dalla lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Restituisce l'ultima stanza dalla lista. La dimensione della lista viene ridotta di uno.
\end{itemize}

\subsubsection{Funzione: \texttt{Room get\_first\_room\_list(RoomList list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_first\_room\_list(RoomList) -> Room}
\item Tipi: \texttt{RoomList}
\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_first\_room\_list(list) -> room}
\item Ottiene la prima stanza nella lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Restituisce la prima stanza nella lista.
\end{itemize}

\subsubsection{Funzione: \texttt{Room get\_at\_room\_list(RoomList list, int pos)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_at\_room\_list(RoomList, int) -> Room}
\item Tipi: \texttt{RoomList, int}
\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_at\_room\_list(list, pos) -> room}
\item Ottiene la stanza alla posizione specificata nella lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido, \texttt{pos} è un indice valido.
\item Postcondizioni: Restituisce la stanza alla posizione specificata nella lista.
\end{itemize}

\subsubsection{Funzione: \texttt{Room get\_room\_by\_id(RoomList list, unsigned int room\_id)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_room\_by\_id(RoomList, unsigned int) -> Room}
\item Tipi: \texttt{RoomList, unsigned int}
\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_room\_by\_id(list, room\_id) -> room}
\item Ottiene la stanza con l'ID specificato dalla lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Restituisce la stanza con l'ID specificato dalla lista, o NULL se non trovata.
\end{itemize}

\subsubsection{Funzione: \texttt{Room remove\_at\_room\_list(RoomList list, int pos)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{remove\_at\_room\_list(RoomList, int) -> Room}
\item Tipi: \texttt{RoomList, int}
\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{remove\_at\_room\_list(list, pos) -> room}
\item Rimuove e restituisce la stanza alla posizione specificata nella lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido, \texttt{pos} è un indice valido.
\item Postcondizioni: Restituisce la stanza rimossa dalla lista.
\end{itemize}

\subsubsection{Funzione: \texttt{int get\_pos\_room\_list(RoomList list, Room to\_search)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{get\_pos\_room\_list(RoomList, Room) -> int}
\item Tipi: \texttt{RoomList, Room}
\item Tipi interni: \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{get\_pos\_room\_list(list, to\_search) -> pos}
\item Ottiene la posizione della stanza specificata nella lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido, \texttt{to\_search} è un oggetto \texttt{Room} valido.
\item Postcondizioni: Restituisce la posizione della stanza nella lista, o -1 se non trovata.
\end{itemize}

\subsubsection{Funzione: \texttt{void print\_room\_list(RoomList list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{print\_room\_list(RoomList) -> void}
\item Tipi: \texttt{RoomList}
\item Tipi interni: int
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{print\_room\_list(list)}
\item Stampa tutte le stanze nella lista.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Stampa i dettagli di ogni stanza nella lista su stdout.
\end{itemize}

\subsubsection{Funzione: \texttt{void save\_room\_list\_to\_file(RoomList list, FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{save\_room\_list\_to\_file(RoomList, FILE*) -> void}
\item Tipi: \texttt{RoomList, FILE*}
\item Tipi interni: int
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{save\_room\_list\_to\_file(list, file)}
\item Salva l'elenco delle stanze su un file.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido, \texttt{file} è un file valido aperto in scrittura.
\item Postcondizioni: Scrive i dettagli di ogni stanza nella lista sullo stream del file.
\end{itemize}

\subsubsection{Funzione: \texttt{RoomList read\_room\_list\_from\_file(FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{read\_room\_list\_from\_file(FILE*) -> RoomList}
\item Tipi: \texttt{FILE*}
\item Tipi interni: \texttt{RoomList}, \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{read\_room\_list\_from\_file(file) -> list}
\item Legge un elenco di stanze da un file.
\item Precondizioni: \texttt{file} è un file valido aperto in lettura.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{RoomList} contenente le stanze lette dal file.
\end{itemize}

\subsubsection{Funzione: \texttt{void free\_room\_list(RoomList list)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{free\_room\_list(RoomList) -> void}
\item Tipi: \texttt{RoomList}
\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{free\_room\_list(list)}
\item Libera la memoria allocata per l'elenco delle stanze.
\item Precondizioni: \texttt{list} è un oggetto \texttt{RoomList} valido.
\item Postcondizioni: Rilascia la memoria allocata per l'oggetto \texttt{RoomList} e tutte le sue stanze contenute.
\end{itemize}

\subsection{Specifica dell'ADT Conference}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: Conference
	\item Tipi utilizzati: EventBst, RoomList, unsigned int
\end{itemize}
\textbf{Specificazione Semantica:} \\
Conference rappresenta una conferenza\\

\textbf{Operatori:}
\begin{itemize}
    \item \texttt{new\_conference(void) -> Conference}
    \item \texttt{add\_conference\_event(Conference conf) -> int}
    \item \texttt{edit\_conference\_event(Conference conf) -> int}
    \item \texttt{remove\_conference\_event(Conference conf) -> int}
    \item \texttt{display\_conference\_schedule(Conference conf) -> voic}
    \item \texttt{display\_conference\_rooms(Conference conf) -> voic}
    \item \texttt{add\_conference\_room(Conference conf) -> int}
    \item \texttt{remove\_conference\_room(Conference conf) -> int}
    \item \texttt{conference\_assign\_event\_to\_room(Conference conf) -> int}
    \item \texttt{conference\_free\_event\_room(Conference conf) -> int}
    \item \texttt{free\_conference(Conference conf) -> void}
    \item \texttt{save\_conference\_to\_file(Conference conf, FILE* file) -> void}
    \item \texttt{save\_conference\_to\_file\_sorted(Conference conf, FILE* file) -> Conference}
    \item \texttt{read\_conference\_from\_file(FILE* file)}
\end{itemize}

\subsubsection{Funzione: \texttt{Conference new\_conference(void)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{new\_conference(void) -> Conference}
\item Tipi: Nessuno
\item Tipo interno: \texttt{Conference}, \texttt{EventBst}, \texttt{RoomList}, \texttt{unsigned int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{new\_conference() -> conferenza}
\item Crea una nuova conferenza vuota per memorizzare eventi e stanze.
\item Precondizioni: Nessuna.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Conference} vuoto.
\end{itemize}


\subsubsection{Funzione: \texttt{int
add\_conference\_event(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{add\_conference\_event(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{add\_conference\_event(conf) -> risultato}
\item Aggiunge un nuovo evento alla conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{int edit\_conference\_event(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{edit\_conference\_event(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{edit\_conference\_event(conf) -> risultato}
\item Modifica un evento esistente nella conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{int remove\_conference\_event(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{remove\_conference\_event(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{remove\_conference\_event(conf) -> risultato}
\item Rimuove un evento dalla conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{void display\_conference\_schedule(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{display\_conference\_schedule(Conference conf) -> void}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}, \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{display\_conference\_schedule(conf)}
\item Mostra l'orario degli eventi nella conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Stampa l'orario degli eventi.
\end{itemize}

\subsubsection{Funzione: \texttt{void display\_conference\_rooms(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{display\_conference\_rooms(Conference conf) -> void}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}, \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{display\_conference\_rooms(conf)}
\item Mostra l'elenco delle stanze disponibili nella conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Stampa l'elenco delle stanze.
\end{itemize}

\subsubsection{Funzione: \texttt{int add\_conference\_room(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{add\_conference\_room(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{add\_conference\_room(conf) -> risultato}
\item Aggiunge una nuova stanza alla conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{int remove\_conference\_room(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{remove\_conference\_room(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{remove\_conference\_room(conf) -> risultato}
\item Rimuove una stanza dalla conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{int conference\_assign\_event\_to\_room(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{conference\_assign\_event\_to\_room(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}, \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{conference\_assign\_event\_to\_room(conf) -> risultato}
\item Assegna un evento a una stanza nella conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{int conference\_free\_event\_room(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{conference\_free\_event\_room(Conference conf) -> int}
\item Tipi: \texttt{Conference}
\item Tipo interno: \texttt{Event}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{conference\_free\_event\_room(conf) -> risultato}
\item Libera la stanza assegnata per un evento nella conferenza.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Restituisce 0 in caso di successo, -1 in caso di errore.
\end{itemize}

\subsubsection{Funzione: \texttt{free\_conference(Conference conf)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{free\_conference(Conference)}
\item Tipi: \texttt{Conference}
\item Tipi interni: \texttt{Event, Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{free\_conference(conf)}
\item Libera la memoria allocata per la conferenza e i suoi eventi e sale.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido.
\item Postcondizioni: Libera la memoria allocata per la conferenza.
\end{itemize}

\subsubsection{Funzione: \texttt{save\_conference\_to\_file(Conference conf, FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{save\_conference\_to\_file(Conference, FILE*) -> void}
\item Tipi: \texttt{Conference, FILE*}
\item Tipi interni: \texttt{Event, Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{save\_conference\_to\_file(conf, file)}
\item Salva i dati della conferenza su un file.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido. \texttt{file} deve puntare a un oggetto \texttt{FILE} valido aperto in modalità scrittura.
\item Postcondizioni: Scrive i dati della conferenza sul file specificato.
\end{itemize}

\subsubsection{Funzione: \texttt{save\_conference\_to\_file\_sorted(Conference conf, FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{save\_conference\_to\_file\_sorted(Conference, FILE*) -> void}
\item Tipi: \texttt{Conference, FILE*}
\item Tipi interni: \texttt{Event, Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{save\_conference\_to\_file\_sorted(conf, file)}
\item Salva i dati della conferenza su un file in ordine ordinato.
\item Precondizioni: \texttt{conf} deve puntare a un oggetto \texttt{Conference} valido. \texttt{file} deve puntare a un oggetto \texttt{FILE} valido aperto in modalità scrittura.
\item Postcondizioni: Scrive i dati della conferenza sul file specificato in ordine ordinato.
\end{itemize}

\subsubsection{Funzione: \texttt{Conference read\_conference\_from\_file(FILE* file)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
\item \texttt{Conference read\_conference\_from\_file(FILE*)}
\item Tipi: \texttt{FILE*}
\item Tipi interni: \texttt{Event, Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
\item Funzione: \texttt{read\_conference\_from\_file(file) -> conf}
\item Legge i dati della conferenza da un file e costruisce un nuovo oggetto conferenza.
\item Precondizioni: \texttt{file} deve puntare a un oggetto \texttt{FILE} valido aperto in modalità lettura.
\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Conference} contenente i dati della conferenza letti dal file.
\end{itemize}

\section{Razionale dei casi di test}
Il file \texttt{test.c} implementa un sistema di testing per il progetto di gestione delle conferenze. Questo sistema è progettato per eseguire una serie di test automatici che verificano il corretto funzionamento delle principali funzionalità del software. Di seguito viene fornita una panoramica del funzionamento del file \texttt{test.c}.

\subsection{Tipi di Test}
Il sistema di testing supporta vari tipi di test, definiti tramite una \texttt{enum} denominata \texttt{TestType}. I tipi di test implementati sono:
\begin{itemize}
    \item \texttt{TEST\_ADD\_EVENT}: Test per l'aggiunta di un evento.
    \item \texttt{TEST\_REMOVE\_EVENT}: Test per la rimozione di un evento.
    \item \texttt{TEST\_EDIT\_EVENT}: Test per la modifica di un evento.
    \item \texttt{TEST\_ASSIGN\_ROOM\_EVENT}: Test per l'assegnazione di una sala a un evento.
    \item \texttt{TEST\_FREE\_ROOM\_EVENT}: Test per la liberazione di una sala assegnata a un evento.
    \item \texttt{TEST\_DISPLAY\_EVENTS}: Test per la visualizzazione del programma della conferenza.
\end{itemize}

\subsection{Funzionamento Generale}
Il file \texttt{test.c} segue questi passaggi per eseguire i test:
\begin{enumerate}
    \item Legge il file di suite di test, il quale contiene le specifiche di ogni test da eseguire.
    \item Per ogni test, carica i file necessari (ex. Per il test TC001 i file saranno contenuti nell'omonima cartella), inclusi i file di input (input.txt), di output atteso (oracle.txt) ed un opzionale file di conferenza iniziale (conference.txt)
    \item Reindirizza l'input e l'output standard per eseguire le operazioni specificate dal tipo di test.
    \item Confronta l'output generato dal test con l'output atteso (oracle) per determinare se il test è passato o fallito.
    \item Registra i risultati di ogni test in un file di risultati.
\end{enumerate}

\subsection{Formato file conferenze}
I file \texttt{conference.txt} e quelli di oracle (tranne nei test di visualizzazione del programma della conferenza) contengono le informazioni relative alla conferenza. Sono strutturati nel seguente modo:

\begin{enumerate}
    \item Le prime due righe rappresentano gli inizializzatori degli ID per eventi e stanze.
    \item Il numero di eventi presenti nella conferenza è indicato dalla riga successiva.
    \item Per ciascun evento, vengono forniti i seguenti dettagli:
    \begin{itemize}
        \item Tipo dell'evento (indicato con un numero tra 1 e 3), ID dell'evento, ID della sala a cui è assegnato l'evento e  nome dell'evento
        \item Data di inizio dell'evento (espressa come ''mm hh GG MM AAAA'')
        \item Data di fine dell'evento (espressa come ''mm hh GG MM AAAA'')
    \end{itemize}
    \item Dopo la lista degli eventi, viene fornito il numero di sale presenti nella conferenza, indicato dalla riga successiva.
    \item Per ciascuna sala, vengono forniti i seguenti dettagli:
    \begin{itemize}
        \item ID della sala
        \item Nome della sala
        \item Posti presenti nella sala
    \end{itemize}
\end{enumerate}



\begin{minipage}{\linewidth}
\paragraph{Esempio:}
Di seguito è riportato un esempio di come deve essere formattato un file contenente una conferenza:

\begin{lstlisting}
4 4
3
1 0 1 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 3 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
3
1
Sala A
50
2
Sala B
50
3
Sala C
50
\end{lstlisting}

\begin{enumerate}
    \item il primo 4 è l'inizializzatore degli ID evento, il secondo è l' inizializzatore degli ID sala
    \item 3 indica il numero di eventi nella conferenza
    \item Il primo evento assume i seguenti valori:
    \begin{itemize}
        \item 1 è l'ID dell'evento, 0 è il tipo dell'evento, 1 è l'ID della sala a cui è assegnato e ``Evento test 1'' è il nome dell'evento
				\item \texttt{01/01/1970 12:00} è la data e l'ora di inizio dell'evento.
				\item \texttt{01/01/1970 13:00} è la data e l'ora di fine dell'evento.
    \end{itemize}
    \item Seguono altri due eventi formattati come il precedente
    \item 3 rappresenta il numero di sale nella conferenza.
    \item La prima sala assume i seguenti valori:
    \begin{itemize}
				\item 1 è l'ID della sala
        \item "Sala A" è il nome della sala
        \item 50 sono i posti della sala
    \end{itemize}
    \item Seguono altre due sale formattate in maniera similare
\end{enumerate}

\end{minipage}

\subsection{Test per l'aggiunta di un evento}
I test di aggiunta di un evento non usano il file opzionale conference.txt. I file output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di Aggiunta Evento}

Per eseguire correttamente i test di aggiunta evento, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare l'aggiunta di un singolo evento. Questo file contiene le informazioni necessarie per aggiungere un nuovo evento alla conferenza, con ogni campo separato su righe diverse:

\begin{itemize}
    \item \textbf{Nome evento}: Una stringa che rappresenta il nome dell'evento.
    \item \textbf{Tipologia evento}: Un intero che indica la tipologia dell'evento (valore tra 1 e 3).
    \item \textbf{Data inizio evento}: La data e l'ora di inizio dell'evento, formattata come \texttt{DD/MM/YYYY HH:MM}.
    \item \textbf{Data fine evento}: La data e l'ora di fine dell'evento, formattata come \texttt{DD/MM/YYYY HH:MM}.
\end{itemize}

Ogni riga non valida viene ignorata

\paragraph{Esempio 1:}
Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
NomeEvento1
1
15/06/2024 09:00
15/06/2024 11:00
\end{lstlisting}

In questo esempio:
\begin{itemize}
    \item \texttt{NomeEvento1} è il nome dell'evento.
    \item \texttt{1} è la tipologia dell'evento.
    \item \texttt{15/06/2024 09:00} è la data e l'ora di inizio dell'evento.
    \item \texttt{15/06/2024 11:00} è la data e l'ora di fine dell'evento.
\end{itemize}

\paragraph{Esempio 2:}

Di seguito è riportato un esempio di come vengono interpretati dei file con righe non valide:

\begin{lstlisting}
NomeEvento1
1
15/06/2024 09:00
15/06/2024 08:00
15/06/2024 11:00
\end{lstlisting}

In questo esempio:
\begin{itemize}
    \item \texttt{NomeEvento1} è il nome dell'evento.
    \item \texttt{1} è la tipologia dell'evento.
    \item \texttt{15/06/2024 09:00} è la data e l'ora di inizio dell'evento.
    \item \texttt{15/06/2024 11:00} è la data e l'ora di fine dell'evento, dato che la riga ''15/06/2024 08:00'' viene ignorata
\end{itemize}


\subsubsection{Casi di test relativi al nome dell'evento}

\begin{itemize}
	\item \textbf{TC001} : testiamo il caso in cui vengano inseriti regolarmente il nome dell’evento, la tipologia dell’evento, data di inizio e di fine.

	\item \textbf{TC002} : testiamo il caso in cui vengano inseriti 101 caratteri nel nome dell’evento. Il programma chiederà nuovamente di inserire il nome perchè il limite (100) è stato superato.

	\item \textbf{TC003} : testiamo il caso in cui vengano inseriti 100 caratteri nel nome dell’evento. Il programma accetterà il nome perchè il 100esimo carattere è compreso nel limite.

	\item \textbf{TC004} : testiamo il caso in cui venga dato un’invio all’inserimento del nome dell’evento. Il programma chiederà nuovamente di inserire il nome dell’evento.

	\item \textbf{TC005} : testiamo il caso in cui vengano dati degli spazi all’inserimento del nome dell’evento. Il programma non considererà gli spazi.

	\item \textbf{TC006} : testiamo il caso in cui vengano dati invii e spazi all’inserimento del nome dell’evento. Il programma continuerà a chiedere il nome dopo ogni invio e ignorerà gli spazi.

\end{itemize}


\subsubsection{Casi di test relativi alla tipologia dell'evento}

\begin{itemize}


	\item \textbf{TC007} : testiamo il caso in cui venga inserita la tipologia “2” dell’evento.

	\item \textbf{TC008} : testiamo il caso in cui venga inserita la tipologia “3” dell’evento.

	\item \textbf{TC009} : testiamo il caso in cui venga inserito 0 alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.

	\item \textbf{TC010} : testiamo il caso in cui venga inserito 4 alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.

	\item \textbf{TC011}: testiamo il caso in cui venga inserito -1 alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.

	\item \textbf{TC012}: testiamo il caso in cui venga inserita una stringa alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.


\end{itemize}


\subsubsection{Casi di test relativi alle date dell'evento}

\begin{itemize}


	\item \textbf{TC013} : testiamo il caso in cui venga inserita una data con il giorno 0. Il programma chiederà nuovamente la data.

	\item \textbf{TC014} : testiamo il caso in cui venga inserita una data con il giorno -1. Il programma chiederà nuovamente la data.

	\item \textbf{TC015} : testiamo il caso in cui venga inserito 31 come giorno a gennaio.

	\item \textbf{TC016} : testiamo il caso  in cui venga inserito 32 come giorno. Il programma chiederà nuovamente la data.

	\item \textbf{TC017} : testiamo il caso  in cui venga inserito 28 come giorno a febbraio in un anno non bisestile.

	\item \textbf{TC018} : testiamo il caso  in cui venga inserito 29 come giorno a febbraio in un anno non bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC019} : testiamo il caso in cui venga inserito 29 come giorno a febbraio in un anno bisestile.

	\item \textbf{TC020} : testiamo il caso in cui venga inserito 30 come giorno a febbraio in un anno bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC021} : testiamo il caso in cui venga inserito 28 come giorno a febbraio in un anno non bisestile.

	\item \textbf{TC022} : testiamo il caso in cui venga inserito 29 come giorno a febbraio in un anno non bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC023} : testiamo il caso in cui venga inserito 29 come giorno a febbraio in un anno  bisestile.

	\item \textbf{TC024} : testiamo il caso  in cui venga inserito 30 come giorno a febbraio in un anno bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC025} fino al \textbf{TC044} : testiamo tutti i casi in cui il giorno superi il limite di giorni in quel determinato mese. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC045} : testiamo il caso in cui venga inserito “13” come mese. Il programma chiederà nuovamente la data.

	\item \textbf{TC046} : testiamo il caso in cui venga inserito “00” come mese. Il programma chiederà nuovamente la data.

	\item \textbf{TC047} : testiamo il caso in cui venga inserito “-01” come mese. Il programma chiederà nuovamente la data.

	\item \textbf{TC048} : testiamo il caso in cui venga inserito “-01” come anno. Il programma chiederà nuovamente la data.

	\item \textbf{TC049} : testiamo il caso in cui venga inserito “24:00” come orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC050} : testiamo il caso in cui venga inserito “-1:00” come orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC051} : testiamo il caso in cui venga inserito “60” come minuti all’interno dell’orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC052} : testiamo il caso in cui venga inserito “-1” come minuti all’interno dell’orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC053} : testiamo il caso in cui venga inserita come seconda data una data minore rispetto alla prima. Il programma chiederà nuovamente la data.

	\item \textbf{TC054} : testiamo il caso in cui venga inserita una data di inizio e di fine uguale. Andrea vaffanculo (spiegherai tu questa cosa).

	\item \textbf{TC054} : testiamo il caso in cui vengano inserite una data di inizio e una di fine uguale, abbiamo deciso di considerare corretto questo caso.

\end{itemize}


\subsection{Test per la rimozione di un evento}
I file conference.txt, output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di Rimozione Evento}

Per eseguire correttamente i test, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare la rimozione di un singolo evento. Questo file contiene l'ID dell'evento da rimuovere.
Gli ID non validi vengono ignorati e la conferenza non viene cambiata


\paragraph{Esempio 1:}
Dato il seguente file conference.txt:
\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}

Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
1
\end{lstlisting}

In questo esempio 1 indica l'ID di ``Evento test 1''\\
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
2
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\paragraph{Esempio 2:}

Considerando la conferenza dell'esempio precedente di seguito si riporta il caso in cui venga inserito un ID non valido:

\begin{lstlisting}
4
\end{lstlisting}
Il valore 4 nella precedente conferenza non è ID di alcun evento.\\
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\subsubsection{Casi di test}
\begin{itemize}

	\item \textbf{TC055} : testiamo il caso in cui venga rimosso l'evento con ID 1.

	\item \textbf{TC056} : testiamo il caso in cui venga rimosso l'evento con ID 2.

	\item \textbf{TC057} : testiamo il caso in cui venga rimosso l'evento con ID 3.

	\item \textbf{TC058} : testiamo il caso in cui venga rimosso l'evento con ID 4. Il programma non considererà la rimozione perché non è presente un evento con ID 4.

	\item \textbf{TC059} : testiamo il caso in cui venga rimosso l'evento con ID -1. Il programma non considererà la rimozione perché non è presente un evento con ID -1.

\end{itemize}

\subsection{Test per la modifica di un evento}

I file conference.txt, output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di Modifica Evento}

Per eseguire correttamente i test, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare la modifica di un singolo evento. Questo file contiene l'ID dell'evento che si desidera modificare, la tipologia di modifica (un numero da 1 a 4 che indica il campo che si desidera modificare: 1 - Nome, 2 - Tipo Evento, 3 - Data inizio, 4 - Data fine) , la modifica e il comando di uscita.
Gli ID non validi vengono ignorati e la conferenza non viene modificata.
Qualsiasi altro valore non valido richiede il reinserimento del dato.



\paragraph{Esempio:}
Dato il seguente file conference.txt:
\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}

Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
1
1
Evento test 4
5
\end{lstlisting}

In questo esempio:
\begin{itemize}
    \item \texttt{1} è l'ID dell'evento "Evento test 1"
    \item \texttt{1} indica che si desidera modificare il nome dell'evento.
    \item \texttt{Evento test 4} è il nuovo nome dell'evento.
    \item \texttt{5} indica l'uscita e il salvataggio della modifica.
\end{itemize}
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
3
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1 0 0 Evento test 4
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\subsubsection{Casi di test}
\begin{itemize}

	\item \textbf{TC060} : testiamo il caso in cui venga modificato un evento già presente con ID 1.

	\item \textbf{TC061} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, diamo un invio. Il programma chiederà di reinserire il nome dell'evento.

	\item \textbf{TC062} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, diamo degli spazi. Il programma non considererà gli spazi.

	\item \textbf{TC063} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, diamo un invio e degli spazi. Il programma ignorerà gli spazi e l'invio chiedendo di reinserire il nome dell'evento.

	\item \textbf{TC064} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, venga inserito un nome che superi il limite di 100 caratteri. Il programma chiederà di inserire nuovamente il nome dell'evento.

	\item \textbf{TC065} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, venga inserito un nome di esattamente 100 caratteri.
 	\item \textbf{TC066} : testiamo il caso in cui venga scelta una tipologia di evento corretta.

	\item \textbf{TC067} : testiamo il caso in cui venga scelta una tipologia di evento corretta.

	\item \textbf{TC068} : testiamo il caso in cui venga scelta una tipologia di evento corretta.

	\item \textbf{TC069} : testiamo il caso in cui venga inserito "0"  come tipologia di evento. Il programma ciederà nuovamente la tipologia.

	\item \textbf{TC070} : testiamo il caso in cui venga inserito "-1" come tipologia di evento. Il programma ciederà nuovamente la tipologia.

	\item \textbf{TC071} : testiamo il caso in cui venga inserito "4"  come tipologia di evento. Il programma ciederà nuovamente la tipologia.

	\item \textbf{TC072} : testiamo il caso in cui venga modificata correttamente la data di inizio.

	\item \textbf{TC073} : testiamo il caso in cui si tenti di inserire una data di inizio successiva rispetto a quella di fine. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC074} : testiamo il caso in cui si tenti di inserire una data di inizio che si sovrapponga alla data di un altro evento nella stessa sala. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC075} : testiamo il caso in cui venga modificata correttamente la data di fine.

	\item \textbf{TC076} : testiamo il caso in cui si tenti di inserire una data di fine precedente rispetto a quella di inizio. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC077} : testiamo il caso in cui si tenti di inserire una data di fine che si sovrapponga alla data di un altro evento nella stessa sala. Il programma chiederà nuovamente di inserire la data.


\end{itemize}

\subsection{Test per l'assegnazione di una sala a un evento}

I file conference.txt, output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di  assegnazione di una sala a un evento}

Per eseguire correttamente i test, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare l'assegnazione di una sala a un evento. Questo file contiene l'ID dell'evento a cui si vuole assegnare la sala e l'ID della sala che si desidera assegnare.
Gli ID non validi vengono ignorati e la conferenza non viene modificata.


\paragraph{Esempio:}
Dato il seguente file conference.txt:
\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}

Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
1
1
\end{lstlisting}

In questo esempio:
\begin{itemize}
    \item \texttt{1} è l'ID dell'evento "Evento test 1"
    \item \texttt{1} è l'ID della sala "Sala A".
\end{itemize}
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
3
1 0 1 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\subsubsection{Casi di test}

\begin{itemize}


	\item \textbf{TC078} : testiamo il caso in cui venga assegnata una sala ad un evento.

	\item \textbf{TC079} : testiamo il caso in cui venga assegnato ad un evento una sala già occupata nel periodo di tempo in cui si verifica.

	\item \textbf{TC080} : testiamo il caso in cui venga assegnata una sala ad un evento che ha la data di fine uguale alla data di inizio dell'evento successivo.

	\item \textbf{TC081} : testiamo il caso in cui venga assegnata una sala ad un evento che ha la data di inizio uguale alla data di fine dell'evento precedente.

	\item \textbf{TC082} : testiamo il caso in cui due eventi abbiano la stessa data di inizio e di fine, ma siano assegnati a sale differenti.


\end{itemize}

\subsection{Test per la liberazione di una sala assegnata a un evento}

I file conference.txt, output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di  liberazione di una sala assegnata a un evento}

Per eseguire correttamente i test, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare l'assegnazione di una sala a un evento. Questo file contiene l'ID dell'evento da cui si vuole rimuovere la sala.
Gli ID non validi vengono ignorati e la conferenza non viene modificata.


\paragraph{Esempio:}
Dato il seguente file conference.txt:
\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}

Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
1
\end{lstlisting}

In questo esempio:
\begin{itemize}
    \item \texttt{1} è l'ID dell'evento "Evento test 1"
\end{itemize}
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\subsubsection{Casi di test}


\begin{itemize}

	\item \textbf{TC083} : testiamo la rimozione di una sala da un evento.

	\item \textbf{TC084} : testiamo la rimozione di una sala inesistente.

	\item \textbf{TC085} : testiamo che un numero negativo annulli la selezione di una sala.

\end{itemize}


\subsection{Test per la visualizzazione del programma dela conferenza}

I file conference.txt è una conferenza formattata come precedentemente descritto. I file output.txt e oracle.txt sono elenchi di eventi. Il file input.txt non è utilizzato. I test stampano gli eventi presenti nel file conference.txt in ordine cronologico.

\paragraph{Esempio:}
Dato il seguente file conference.txt:
\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}

Il file output.txt sarà quindi:

\begin{lstlisting}
Id: 1
Evento: "Evento test 1"
Tipo: Workshop
Data inizio: 1 Gennaio 1970, 12:00
Data fine: 1 Gennaio 1970, 13:00

Id: 2
Evento: "Evento test 2"
Tipo: Sessione di keynote
Data inizio: 1 Gennaio 1970, 12:00
Data fine: 1 Gennaio 1970, 13:00

Id: 3
Evento: "Evento test 3"
Tipo: Panel di discussione
Data inizio: 1 Gennaio 1970, 12:00
Data fine: 1 Gennaio 1970, 13:00

\end{lstlisting}

\subsubsection{Casi di test}

\begin{itemize}


	\item \textbf{TC086} : testiamo la corretta visualizzazione degli eventi in ordine alfabetico, perché le date sono tutte uguali.

	\item \textbf{TC087} : testiamo la corretta visualizzazione degli eventi con ID non ordinati.

	\item \textbf{TC088} : testiamo la corretta visualizzazione degli eventi con tutte le sale assegnate.

	\item \textbf{TC089} : testiamo la corretta visualizzazione degli eventi, con solo due sale assegnate a due eventi.

	\item \textbf{TC090} : testiamo la corretta visualizzazione degli eventi seguendo l'ordine delle date.

	\item \textbf{TC091} : visualizzazione di eventi multipli che combinano i precedenti test case.

	\item \textbf{TC092} : visualizzazione di lista di eventi vuota.
\end{itemize}

\begin{minipage}{\linewidth}
\section{Compilazione e esecuzione programmi}

\subsection{Compilazione e esecuzione dell'eseguibile principale}
Per generare il file eseguibile principale, eseguire il comando:
\begin{verbatim}
make bin/progetto
\end{verbatim}
Il file risultante si troverà nella cartella \texttt{bin} e avrà il nome \texttt{progetto}. Il programma non richiede argomenti aggiuntivi da riga di comando per essere eseguito, ma può essere fornito il nome di un file di conferenza da cui leggere o in cui scrivere.

\paragraph{Esempio:}
\begin{verbatim}
./progetto {conference.txt}
\end{verbatim}


\subsection{Compilazione e esecuzione del programma di testing}
Per generare il file eseguibile per i test, eseguire il comando:
\begin{verbatim}
make tests/test
\end{verbatim}
Il file risultante si troverà nella cartella \texttt{tests} e avrà il nome \texttt{test}. L'eseguibile deve essere eseguito nella cartella contenente i test case (\texttt{tests}). Per l'esecuzione, il programma richiede un file di test suite e un file dove scrivere i risultati.

\paragraph{Esempio:}
\begin{verbatim}
./test test_suite.txt result.txt
\end{verbatim}

\end{minipage}

%-----------------------------------------------%

\end{document}
