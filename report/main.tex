%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Wenneker Assignment
% LaTeX Template
% Version 2.0 (12/1/2019)
%
% This template originates from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@LaTeXTemplates.com)
% Frits Wenneker
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt]{scrartcl} % Font size
% \usepackage{beamer}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{
	\normalfont\normalsize
	\textsc{Università degli studi di Salerno}\\ % Your university, school and/or department name(s)
	\vspace{25pt} % Whitespace
	\rule{\linewidth}{0.5pt}\\ % Thin top horizontal rule
	\vspace{20pt} % Whitespace
	{\huge Progetto Programmazione e Strutture Dati}\\ % The assignment title
	\vspace{12pt} % Whitespace
	\rule{\linewidth}{2pt}\\ % Thick bottom horizontal rule
	\vspace{12pt} % Whitespace
}


\author{
	\LARGE
	Robustelli Renato \\
	\LARGE
	Squitieri Andrea \\
	\LARGE
	Vitolo Angelo
} % Your name

% \date{\normalsize\today} % Today's date (\today) or a custom date
\date{\null}

\begin{document}

\maketitle % Print the title


%----------------------------------------------------------------------------------------
%	FIGURE EXAMPLE
%----------------------------------------------------------------------------------------

\section{Introduzione}


%------------------------------------------------


Il progetto si concentra sulla creazione di un sistema di gestione delle conferenze, con l'obiettivo di organizzare e gestire eventi e stanze in modo efficiente. Il sistema è progettato per facilitare la pianificazione, la modifica, la visualizzazione e l'archiviazione di eventi e stanze all'interno di una conferenza.



\subsection{Obiettivi del progetto}
Gli obiettivi principali del progetto includono:

\begin{itemize}
	\item  Gestione di Conferenze: Possibilità di aggiungere, modificare e rimuovere eventi e stanze di una conferenza.
	\item Assegnazione delle Stanze: Funzionalità per assegnare stanze a specifici eventi.
	\item Visualizzazione delle Informazioni: Strumenti per visualizzare gli eventi ordinati per data d'inizio.
	\item Persistenza dei Dati: Capacità di salvare e caricare i dati delle conferenze da file per garantire la persistenza delle informazioni.
\end{itemize}

%----------------------------------------------------------------------------------------
%	TEXT EXAMPLE
%----------------------------------------------------------------------------------------

\section{Motivazione della scelta degli ADT}

\subsection{Motivazioni per l'uso dell'ADT Date, dell'ADT Room e dell'ADT Event}

Gli eventi devono essere pianificati in specifici giorni e orari. Per garantire una gestione precisa e coerente di queste informazioni, è stato sviluppato l'ADT Date. L'uso di questo ADT permette di:
\begin{itemize}
	\item \textbf{Assicurare la validità delle date}: Le date inserite nel sistema sono sempre valide (es. nessuna data con un mese o giorno inesistente).
	\item \textbf{Effettuare confronti corretti tra date}: Il confronto tra due date avviene in maniera corretta e semplice.
\end{itemize}
In particolare, l'ADT Date viene utilizzato per rappresentare le date di inizio e fine di ogni evento, con una precisione che arriva al minuto.

\subsection{Motivazioni per l'uso dell'ADT Room}

L'ADT Room gestisce le informazioni relative alle sale all'interno del sistema di gestione delle conferenze. Esso rappresenta una sala con attributi quali il nome della sala, il numero di posti e l'eventuale disponibilità.

\subsection{Motivazioni per l'uso dell'ADT RoomList}

L'ADT RoomList è stato introdotto per gestire in modo efficiente un insieme di sale conferenze. Esso rappresenta una collezione di oggetti Room, permettendo di mantenere organizzate e facilmente accessibili tutte le informazioni relative alle diverse sale.

\subsection{Motivazioni per l'uso dell'ADT Event}

L'ADT Event è stato creato per gestire in modo efficiente le informazioni relative agli eventi all'interno del sistema. Esso rappresenta un singolo evento, includendo dettagli cruciali come il nome dell'evento, la data e l'ora di inizio e fine, e la sala assegnata.

\subsection{Motivazioni per l'uso dell'ADT EventBst}

L'ADT EventBst è stato introdotto per gestire in modo ordinato la raccolta di eventi all'interno del sistema. Esso rappresenta un albero binario di ricerca in cui ogni nodo contiene un singolo evento, e le relazioni di ordinamento sono definite sulla base delle proprietà degli eventi, come la data e l'ora di inizio e, se condivise da altri eventi, il nome.

L'uso di un albero binario di ricerca permette di aggiungere eventi con una complessità temporale media di $O(\log{n})$. Tuttavia, per favorire l'usabilità del software, le operazioni di modifica e rimozione non possono sfruttare le proprietà dell'albero e sono quindi di complessità $O(n)$ (precedute da una ricerca lineare per ID dell'evento).

Nonostante ciò, riteniamo che l'uso di questo ADT sia giustificato, dato che le possibili alternative avrebbero comunque mantenuto una complessità temporale di $O(n)$ nella modifica e nella rimozione, ma avrebbero reso lineare anche la complessità dell'aggiunta degli eventi.

\subsection{Motivazioni per l'uso dell'ADT Conference}

L'ADT Conference è stato implementato per gestire in modo completo e strutturato l'organizzazione di una conferenza, inclusi gli eventi, le sale e le loro assegnazioni. Esso è progettato come un'astrazione completa della conferenza, comprendendo una collezione di eventi, una lista delle sale disponibili e le assegnazioni degli eventi alle sale.

Grazie a questa astrazione, ci assicuriamo che ciascun evento e sala siano identificati da ID univoci e che non vi siano sovrapposizioni temporali tra gli eventi assegnati alla stessa sala.

\section{Progettazione}

\section{Specifiche sintattiche e semantiche}

\subsection{Funzioni e tipi di logging}

\subsubsection{Specificazione del tipo \texttt{LogLevel}}

Definisce un tipo enumerato chiamato \texttt{LogLevel} con i seguenti valori:
\begin{itemize}
	\item \texttt{LOG\_INFO}: Messaggi informativi.
	\item \texttt{LOG\_WARN}: Messaggi di avviso.
	\item \texttt{LOG\_ERROR}: Messaggi di errore.
\end{itemize}

\subsubsection{Specificazione di \texttt{set\_log\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{set\_log\_file(FILE*)}
	\item tipi: \texttt{FILE*}
	\item tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{set\_log\_file(file)}
	\item Imposta il file di log al file specificato.
	\item Precondizioni: \texttt{file} è un puntatore \texttt{FILE} valido aperto in modalità scrittura.
	\item Postcondizioni: Le funzioni di log scriveranno nel file specificato. Se \texttt{file} è \texttt{NULL}, le funzioni di log non scriveranno in nessun file.
\end{itemize}



\subsubsection{Specificazione di \texttt{log\_message(LogLevel, const char*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{log\_message(LogLevel, const char*)}
	\item tipi: \texttt{LogLevel}, \texttt{const char*}
	\item tipi interni: \texttt{time\_t}, \texttt{struct tm}, \texttt{char[]}, \texttt{FILE*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{log\_message(level, message)}
	\item Registra un messaggio con il livello di log specificato.
	\item Precondizioni:
	      \begin{itemize}
		      \item \texttt{level} è uno tra \texttt{LOG\_INFO}, \texttt{LOG\_WARN}, \texttt{LOG\_ERROR}.
		      \item \texttt{message} è un puntatore non nullo a una stringa terminata da null.
		      \item Il file di log è stato impostato usando \texttt{set\_log\_file}.
	      \end{itemize}
	\item Postcondizioni:
	      \begin{itemize}
		      \item Il messaggio è scritto nel file di log con un prefisso che include timestamp e livello di log.
		      \item Se il file di log non è impostato, non sarà generato alcun output.
	      \end{itemize}
\end{itemize}

\subsubsection{Specificazione di \texttt{log\_error(const char*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{log\_error(const char*)}
	\item tipi: \texttt{const char*}
	\item tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{log\_error(message)}
	\item Registra un messaggio di errore.
	\item Precondizioni:
	      \begin{itemize}
		      \item \texttt{message} è un puntatore non nullo a una stringa.
		      \item Il file di log è stato impostato usando \texttt{set\_log\_file}.
	      \end{itemize}
	\item Postcondizioni:
	      \begin{itemize}
		      \item Il messaggio di errore è scritto nel file di log con un prefisso che include timestamp e la dicitura "ERROR".
		      \item Se il file di log non è impostato, non sarà generato alcun output.
	      \end{itemize}
\end{itemize}

\subsection{Funzioni e tipi di utilità}

\subsubsection{Specificazione del tipo \texttt{ResultInt}}


\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: ResultInt
	\item Tipi utilizzati: int
	\item Campi:
	      \begin{itemize}
		      \item error\_code: Codice di errore: 0 per successo, valori negativi per gli errori.
		      \item value: Valore intero risultante.
	      \end{itemize}
\end{itemize}



\textbf{Specificazione Semantica:} \\
Rappresenta il valore intero di ritorno di un'operazione che potrebbe fallire.

\subsubsection{Funzione \texttt{clean\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{clean\_file(FILE*)}
	\item Tipi: \texttt{FILE*}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{clean\_file(file)}
	\item Scarta i caratteri dal flusso del file fino a raggiungere una nuova riga o la fine del file.
	\item Precondizioni: 'file' è un puntatore FILE valido aperto in modalità lettura.
	\item Postcondizioni: Il puntatore del file viene avanzato oltre i caratteri scartati.
\end{itemize}

\subsubsection{Funzione \texttt{int read\_line\_from\_file(char*, int, FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_line\_from\_file(char*, int, FILE*) -> int}
	\item Tipi: \texttt{char*, int, FILE*}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_line\_from\_file(line, size, file) -> res}
	\item  Legge una riga dal file specificato nel buffer, assicurandosi che ci sia spazio per essa e  gestendo eventuali errori.
	\item Precondizioni: 'line' è un buffer valido di dimensione 'size'. 'file' è un puntatore FILE valido aperto in modalità lettura.
	\item Postcondizioni: In caso di successo, la riga viene memorizzata in 'line' senza il carattere di nuova riga. In caso di fallimento, restituisce -1 se viene raggiunta la fine del file, -2 se la riga è troppo lunga e -3 se si verifica un errore di lettura.
\end{itemize}

\subsubsection{Funzione \texttt{int read\_line(char*, int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_line(char*, int) -> int}
	\item Tipi: \texttt{char*, int}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_line(line, size) -> res}
	\item Legge una riga dallo standard input nel buffer.
	\item Precondizioni: 'line' è un buffer valido di dimensione 'size'.
	\item Postcondizioni: In caso di successo, la riga viene memorizzata in 'line' senza il carattere di nuova riga. In caso di errore, restituisce -1 se si raggiunge la fine del file, -2 se la riga è troppo lunga e -3 se si verifica un errore di lettura.
\end{itemize}

\subsubsection{Funzione \texttt{ResultInt read\_int(void)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_int(void) -> ResultInt}
	\item Tipi: \texttt{ResultInt}
	\item Tipi interni: \texttt{int}, \texttt{char[]}, \texttt{char*}, \texttt{long}, \texttt{errno\_t}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_int() -> res}
	\item Legge un intero dallo standard input e gestisce gli errori.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: In caso di successo, restituisce un \texttt{ResultInt} con il valore dell'intero e \texttt{error\_code} pari a 0. In caso di errore, \texttt{error\_code} viene impostato a -1 per errori di lettura, -2 per errori di intervallo e -3 per input non valido.
\end{itemize}

\subsubsection{Funzione \texttt{my\_alloc(unsigned long, unsigned long)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{my\_alloc(unsigned long, unsigned long)}
	\item Tipi: \texttt{unsigned long}
	\item Tipi interni: \texttt{void*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{my\_alloc(nmemb, size)}
	\item Alloca memoria per un array di 'nmemb' elementi, ciascuno di dimensione 'size' byte e inizializza tutti i byte a zero.
	\item Precondizioni: 'nmemb' e 'size' devono essere diversi da zero.
	\item Postcondizioni: In caso di successo, restituisce un puntatore alla memoria allocata. In caso di errore, registra un errore e termina il programma.
\end{itemize}

\subsubsection{Funzione \texttt{my\_realloc(void*, unsigned long, unsigned long)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{my\_realloc(void*, unsigned long, unsigned long)}
	\item Tipi: \texttt{void*}, \texttt{unsigned long}
	\item Tipi interni: \texttt{void*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{my\_realloc(p, nmemb, size)}
	\item Rialloca la memoria per un array di 'nmemb' elementi, ciascuno di dimensione 'size' byte.
	\item Precondizioni: 'p' è un puntatore a un blocco di memoria precedentemente allocato dinamicamente o NULL. 'nmemb' e 'size' devono essere diversi da zero.
	\item Postcondizioni: In caso di successo, restituisce un puntatore alla memoria riallocata. In caso di errore, registra un errore e termina il programma.
\end{itemize}

\subsubsection{Funzione \texttt{char* my\_strdup(const char*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{my\_strdup(const char*) -> char*}
	\item Tipi: \texttt{char*}
	\item Tipi interni: \texttt{char*}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{my\_strdup(string) -> res\_string}
	\item Duplica la stringa data.
	\item Precondizioni: 'string' è una stringa valida terminata da '\textbackslash0'.
	\item Postcondizioni: In caso di successo, restituisce un puntatore alla stringa duplicata. In caso di errore, registra un errore e termina il programma.
\end{itemize}

\subsubsection{Funzione \texttt{trim\_whitespaces(char*, char*, int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{trim\_whitespaces(char*, char*, int)}
	\item Tipi: \texttt{char*}, \texttt{char*}, \texttt{int}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{trim\_whitespaces(dest, src, max\_size)}
	\item Rimuove gli spazi vuoti iniziali e finali dalla stringa di origine 'src' e la copia nel buffer di destinazione 'dest'.
	\item Precondizioni: 'dest' e 'src' sono puntatori validi, 'max\_size' è la dimensione di 'dest'.
	\item Postcondizioni: 'dest' contiene la stringa senza spazi vuoti. Se 'max\_size' è 0, la funzione non fa nulla.
\end{itemize}

\subsection{Specifica dell'ADT Date}

\subsubsection{Specificazione del tipo \texttt{Date}}


\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: Date
	\item Tipi utilizzati: unsigned char, unsigned short
	\item Campi:
	      \begin{itemize}
		      \item minutes: Campo rappresentante i minuti.
		      \item hour: Campo rappresentante le ore.
		      \item day: Campo rappresentante i giorni.
		      \item months: Campo rappresentante i mesi.
		      \item year: Campo rappresentante gli anni.
	      \end{itemize}
\end{itemize}

\textbf{Specificazione Semantica:} \\
Rappresenta una data valida con precisione al minuto.

\subsubsection{Funzione \texttt{Date new\_date(unsigned char, unsigned char, unsigned char, unsigned char, unsigned short) }}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{new\_date(unsigned char, unsigned char, unsigned char, unsigned char, unsigned short) -> Date}
	\item Tipi: \texttt{unsigned char}, \texttt{unsigned short}
	\item Tipi interni: \texttt{Date}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{new\_date(minutes, hour, day, month, year) -> return\_date}
	\item Crea un nuovo oggetto \texttt{Date} con i componenti specificati.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} creato o NULL se la data non è valida. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione \texttt{Date copy\_date(ConstDate)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{copy\_date(ConstDate) -> Date}
	\item Tipi: \texttt{Date}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{copy\_date(date) -> return\_date}
	\item Crea una copia dell'oggetto \texttt{Date} fornito.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} creato, che è una copia di 'date'. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione \texttt{int cmp\_date(ConstDate, ConstDate) }}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{cmp\_date(ConstDate, ConstDate) -> int}
	\item Tipi: \texttt{ConstDate}
	\item Tipi interni: \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item Confronta due oggetti \texttt{Date}.
	\item Precondizioni: 'date\_a' e 'date\_b' sono oggetti \texttt{Date} validi.
	\item Postcondizioni: Restituisce un intero minore di zero, uguale a zero o maggiore di zero se 'date\_a' è rispettivamente inferiore, uguale o superiore a 'date\_b'.
\end{itemize}

\subsubsection{Funzione \texttt{save\_date\_to\_file(ConstDate, FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{save\_date\_to\_file(ConstDate, FILE*)}
	\item Tipi: \texttt{ConstDate}, \texttt{FILE*}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{save\_date\_to\_file(date, file)}
	\item Salva l'oggetto \texttt{Date} fornito in 'file'.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido. 'file' è un file valido aperto in scrittura.
	\item Postcondizioni: I componenti di 'date' vengono scritti nel file 'file'.
\end{itemize}

\subsubsection{Funzione \texttt{Date read\_date\_from\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_date\_from\_file(FILE*) -> Date}
	\item Tipi: \texttt{FILE*}
	\item Tipi interni: \texttt{Date}, \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_date\_from\_file(file) -> return\_date}
	\item Legge un oggetto \texttt{Date} da un file.
	\item Precondizioni: 'file' è un file valido.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} letto dal file 'file', o NULL se la lettura fallisce. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione \texttt{print\_date(ConstDate)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{print\_date(ConstDate)}
	\item Tipi: \texttt{ConstDate}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{print\_date(date)}
	\item Stampa i componenti dell'oggetto \texttt{Date} su stdout in un formato leggibile dall'utente.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido.
	\item Postcondizioni: I componenti di 'date' vengono stampati su stdout in un formato comprensibile.
\end{itemize}

\subsubsection{Funzione: \texttt{Date read\_date(void)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_date(void) -> Date}
	\item Tipi: Nessuno
	\item Tipi interni: \texttt{Date}, \texttt{int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_date() -> return\_date}
	\item Legge un oggetto \texttt{Date} dall'input standard.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Date} letto dall'input standard (stdin), o NULL se la lettura fallisce. Il chiamante è responsabile di liberare la memoria allocata utilizzando \texttt{free\_date()}.
\end{itemize}

\subsubsection{Funzione: \texttt{free\_date(Date)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{free\_date(Date)}
	\item Tipi: \texttt{Date}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{free\_date(date)}
	\item Libera la memoria allocata per un oggetto \texttt{Date}.
	\item Precondizioni: 'date' è un oggetto \texttt{Date} valido.
	\item Postcondizioni: La memoria allocata per 'date' viene deallocata.
\end{itemize}

\subsection{Specifica dell'ADT Room}

\subsubsection{Specificazione del tipo \texttt{Room}}


\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item Tipo di riferimento: Room
	\item Tipi utilizzati: unsigned int, char*
	\item Campi:
	      \begin{itemize}
		      \item id: Campo rappresentante l'ID dell'oggetto Room.
		      \item name: Campo rappresentante il nome della sala.
		      \item capacity: Campo rappresentante i posti all'interno della sala.

	      \end{itemize}
\end{itemize}
\textbf{Specificazione Semantica:} \\
Rappresenta una sala della conferenza.

\subsubsection{Funzione: \texttt{Room new\_room(const char*, unsigned int, unsigned int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{new\_room(const char* name, unsigned int id, unsigned int capacity) -> Room}
	\item Tipi: \texttt{const char *}, \texttt{unsigned int}
	\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{new\_room(name, id, capacity) -> return\_room}
	\item Crea un nuovo oggetto \texttt{Room} con il nome, l'ID e la capacità specificati.
	\item Precondizioni: 'name' è una stringa valida che rappresenta il nome della stanza. 'id' è un intero non negativo che rappresenta l'ID della stanza. 'capacity' è un intero non negativo che rappresenta la capacità della stanza.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Room} creato, o NULL se si verifica un errore. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{Room copy\_room(ConstRoom)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{copy\_room(ConstRoom room) -> Room}
	\item Tipi: \texttt{ConstRoom}
	\item Tipi interni: \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{copy\_room(room) -> return\_room}
	\item Crea una copia dell'oggetto \texttt{Room} fornito.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: Restituisce un puntatore alla copia appena creata di \texttt{room}. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{bool are\_rooms\_equal(ConstRoom, ConstRoom)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{are\_rooms\_equal(ConstRoom room\_a, ConstRoom room\_b) -> bool}
	\item Tipi: \texttt{ConstRoom}, \texttt{bool}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{are\_rooms\_equal(room\_a, room\_b) -> result}
	\item Verifica se due oggetti \texttt{Room} sono uguali in base ai loro ID.
	\item Precondizioni: I parametri di input \texttt{room\_a} e \texttt{room\_b} sono oggetti \texttt{Room} validi.
	\item Postcondizioni: Restituisce true se \texttt{room\_a} e \texttt{room\_b} hanno lo stesso ID, altrimenti false.
\end{itemize}

\subsubsection{Funzione: \texttt{const char* get\_room\_name(ConstRoom)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{get\_room\_name(ConstRoom room) -> const char*}
	\item Tipi: \texttt{ConstRoom}, \texttt{const char *}
	\item Tipi interni: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{get\_room\_name(room) -> name}
	\item Ottiene il nome dell'oggetto \texttt{Room} fornito.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: Restituisce un puntatore al nome di \texttt{room}.
\end{itemize}

\subsubsection{Funzione: \texttt{unsigned int get\_room\_id(ConstRoom)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{get\_room\_id(ConstRoom room) -> unsigned int}
	\item Tipi: \texttt{ConstRoom}, \texttt{unsigned int}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{get\_room\_id(room) -> id}
	\item Ottiene l'ID dell'oggetto \texttt{Room} fornito.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: Restituisce l'ID di \texttt{room}.
\end{itemize}

\subsubsection{Funzione: \texttt{print\_room(ConstRoom)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{print\_room(ConstRoom room) -> void}
	\item Tipi: \texttt{ConstRoom}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{print\_room(room)}
	\item Stampa i dettagli dell'oggetto \texttt{Room} fornito su stdout.
	\item Precondizioni: Il parametro di input \texttt{room} è un oggetto \texttt{Room} valido.
	\item Postcondizioni: I dettagli di \texttt{room} sono stampati su stdout.
\end{itemize}

\subsubsection{Funzione: \texttt{Room read\_room(unsigned int)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_room(unsigned int id) -> Room}
	\item Tipi: \texttt{unsigned int}, \texttt{Room}
	\item Tipo interno: \texttt{char[]}, \texttt{ResultInt}, \texttt{Room}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_room(id) -> room}
	\item Legge i dettagli di un oggetto \texttt{Room} da stdin e crea un nuovo oggetto \texttt{Room} con id 'id'.
	\item Precondizioni: Nessuna.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Room} creato, o NULL se si verifica un errore. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{save\_room\_to\_file(ConstRoom, FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{save\_room\_to\_file(ConstRoom room, FILE* file)}
	\item Tipi: \texttt{ConstRoom} , \texttt{FILE*}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{save\_room\_to\_file(room, file)}
	\item Salva i dettagli dell'oggetto \texttt{Room} fornito su un file.
	\item Precondizioni: 'room' è un oggetto \texttt{Room} valido. 'file' è un file valido aperto in scrittura.
	\item Postcondizioni: I dettagli di \texttt{room} sono scritti sul file 'file'.
\end{itemize}

\subsubsection{Funzione: \texttt{Room read\_room\_from\_file(FILE*)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{read\_room\_from\_file(FILE* file) -> Room}
	\item Tipi: \texttt{FILE*}, \texttt{Room}
	\item Tipo interno: \texttt{char[]}, \texttt{unsigned int}
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{read\_room\_from\_file(file) -> room}
	\item Legge i dettagli di un oggetto \texttt{Room} da un file e crea un nuovo oggetto \texttt{Room}.
	\item Precondizioni: 'file' è un file valido aperto in lettura.
	\item Postcondizioni: Restituisce un puntatore al nuovo oggetto \texttt{Room} creato, o NULL se si verifica un errore. Il chiamante è responsabile di liberare la memoria allocata utilizzando la funzione \texttt{free\_room()}.
\end{itemize}

\subsubsection{Funzione: \texttt{free\_room(Room)}}

\textbf{Specificazione Sintattica:}
\begin{itemize}
	\item \texttt{free\_room(Room room)}
	\item Tipi: \texttt{Room}
	\item Tipo interno: Nessuno
\end{itemize}

\textbf{Specificazione Semantica:}
\begin{itemize}
	\item \texttt{free\_room(room)}
	\item Libera la memoria allocata per un oggetto \texttt{Room}.
	\item Precondizioni: 'room' è un oggetto \texttt{Room} valido.
	\item Postcondizioni: La memoria allocata per 'room' viene deallocata.
\end{itemize}


\section{Razionale dei casi di test}
Il file \texttt{test.c} implementa un sistema di testing per il progetto di gestione delle conferenze. Questo sistema è progettato per eseguire una serie di test automatici che verificano il corretto funzionamento delle principali funzionalità del software. Di seguito viene fornita una panoramica del funzionamento del file \texttt{test.c}.

\subsection{Tipi di Test}
Il sistema di testing supporta vari tipi di test, definiti tramite una \texttt{enum} denominata \texttt{TestType}. I tipi di test implementati sono:
\begin{itemize}
	\item \texttt{TEST\_ADD\_EVENT}: Test per l'aggiunta di un evento.
	\item \texttt{TEST\_REMOVE\_EVENT}: Test per la rimozione di un evento.
	\item \texttt{TEST\_EDIT\_EVENT}: Test per la modifica di un evento.
	\item \texttt{TEST\_ASSIGN\_ROOM\_EVENT}: Test per l'assegnazione di una sala a un evento.
	\item \texttt{TEST\_FREE\_ROOM\_EVENT}: Test per la liberazione di una sala assegnata a un evento.
	\item \texttt{TEST\_DISPLAY\_EVENTS}: Test per la visualizzazione del programma della conferenza.
\end{itemize}

\subsection{Funzionamento Generale}
Il file \texttt{test.c} segue questi passaggi per eseguire i test:
\begin{enumerate}
	\item Legge il file di suite di test, il quale contiene le specifiche di ogni test da eseguire.
	\item Per ogni test, carica i file necessari (ex. Per il test TC001 i file saranno contenuti nell'omonima cartella), inclusi i file di input (input.txt), di output atteso (oracle.txt) ed un opzionale file di conferenza iniziale (conference.txt)
	\item Reindirizza l'input e l'output standard per eseguire le operazioni specificate dal tipo di test.
	\item Confronta l'output generato dal test con l'output atteso (oracle) per determinare se il test è passato o fallito.
	\item Registra i risultati di ogni test in un file di risultati.
\end{enumerate}

\subsection{Formato file conferenze}
I file \texttt{conference.txt} e quelli di oracle (tranne nei test di visualizzazione del programma della conferenza) contengono le informazioni relative alla conferenza. Sono strutturati nel seguente modo:

\begin{enumerate}
	\item Le prime due righe rappresentano gli inizializzatori degli ID per eventi e stanze.
	\item Il numero di eventi presenti nella conferenza è indicato dalla riga successiva.
	\item Per ciascun evento, vengono forniti i seguenti dettagli:
	      \begin{itemize}
		      \item Tipo dell'evento (indicato con un numero tra 1 e 3), ID dell'evento, ID della sala a cui è assegnato l'evento e  nome dell'evento
		      \item Data di inizio dell'evento (espressa come ''mm hh GG MM AAAA'')
		      \item Data di fine dell'evento (espressa come ''mm hh GG MM AAAA'')
	      \end{itemize}
	\item Dopo la lista degli eventi, viene fornito il numero di sale presenti nella conferenza, indicato dalla riga successiva.
	\item Per ciascuna sala, vengono forniti i seguenti dettagli:
	      \begin{itemize}
		      \item ID della sala
		      \item Nome della sala
		      \item Posti presenti nella sala
	      \end{itemize}
\end{enumerate}



\begin{minipage}{\linewidth}
	\paragraph{Esempio:}
	Di seguito è riportato un esempio di come deve essere formattato un file contenente una conferenza:

	\begin{lstlisting}
4 4
3
1 0 1 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 3 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
3
1
Sala A
50
2
Sala B
50
3
Sala C
50
\end{lstlisting}

	\begin{enumerate}
		\item il primo 4 è l'inizializzatore degli ID evento, il secondo è l' inizializzatore degli ID sala
		\item 3 indica il numero di eventi nella conferenza
		\item Il primo evento assume i seguenti valori:
		      \begin{itemize}
			      \item 1 è l'ID dell'evento, 0 è il tipo dell'evento, 1 è l'ID della sala a cui è assegnato e ``Evento test 1'' è il nome dell'evento
			      \item \texttt{01/01/1970 12:00} è la data e l'ora di inizio dell'evento.
			      \item \texttt{01/01/1970 13:00} è la data e l'ora di fine dell'evento.
		      \end{itemize}
		\item Seguono altri due eventi formattati come il precedente
		\item 3 rappresenta il numero di sale nella conferenza.
		\item La prima sala assume i seguenti valori:
		      \begin{itemize}
			      \item 1 è l'ID della sala
			      \item Sala A è il nome della sala
			      \item 50 sono i posti della sala
		      \end{itemize}
		\item Seguono altre due sale formattate in maniera similare
	\end{enumerate}

\end{minipage}

\subsection{Test per l'aggiunta di un evento}
I test di aggiunta di un evento non usano il file opzionale conference.txt. I file output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di Aggiunta Evento}

Per eseguire correttamente i test di aggiunta evento, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare l'aggiunta di un singolo evento. Questo file contiene le informazioni necessarie per aggiungere un nuovo evento alla conferenza, con ogni campo separato su righe diverse:

\begin{itemize}
	\item \textbf{Nome evento}: Una stringa che rappresenta il nome dell'evento.
	\item \textbf{Tipologia evento}: Un intero che indica la tipologia dell'evento (valore tra 1 e 3).
	\item \textbf{Data inizio evento}: La data e l'ora di inizio dell'evento, formattata come \texttt{DD/MM/YYYY HH:MM}.
	\item \textbf{Data fine evento}: La data e l'ora di fine dell'evento, formattata come \texttt{DD/MM/YYYY HH:MM}.
\end{itemize}

Ogni riga non valida viene ignorata

\paragraph{Esempio 1:}
Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
NomeEvento1
1
15/06/2024 09:00
15/06/2024 11:00
\end{lstlisting}

In questo esempio:
\begin{itemize}
	\item \texttt{NomeEvento1} è il nome dell'evento.
	\item \texttt{1} è la tipologia dell'evento.
	\item \texttt{15/06/2024 09:00} è la data e l'ora di inizio dell'evento.
	\item \texttt{15/06/2024 11:00} è la data e l'ora di fine dell'evento.
\end{itemize}

\paragraph{Esempio 2:}

Di seguito è riportato un esempio di come vengono interpretati dei file con righe non valide:

\begin{lstlisting}
NomeEvento1
1
15/06/2024 09:00
15/06/2024 08:00
15/06/2024 11:00
\end{lstlisting}

In questo esempio:
\begin{itemize}
	\item \texttt{NomeEvento1} è il nome dell'evento.
	\item \texttt{1} è la tipologia dell'evento.
	\item \texttt{15/06/2024 09:00} è la data e l'ora di inizio dell'evento.
	\item \texttt{15/06/2024 11:00} è la data e l'ora di fine dell'evento, dato che la riga ''15/06/2024 08:00'' viene ignorata
\end{itemize}


\subsubsection{Casi di test relativi al nome dell'evento}

\begin{itemize}
	\item \textbf{TC001} : testiamo il caso in cui vengano inseriti regolarmente il nome dell’evento, la tipologia dell’evento, data di inizio e di fine.

	\item \textbf{TC002} : testiamo il caso in cui vengano inseriti 101 caratteri nel nome dell’evento. Il programma chiederà nuovamente di inserire il nome perchè il limite (100) è stato superato.

	\item \textbf{TC003} : testiamo il caso in cui vengano inseriti 100 caratteri nel nome dell’evento. Il programma accetterà il nome perchè il 100esimo carattere è compreso nel limite.

	\item \textbf{TC004} : testiamo il caso in cui venga dato un’invio all’inserimento del nome dell’evento. Il programma chiederà nuovamente di inserire il nome dell’evento.

	\item \textbf{TC005} : testiamo il caso in cui vengano dati degli spazi all’inserimento del nome dell’evento. Il programma non considererà gli spazi.

	\item \textbf{TC006} : testiamo il caso in cui vengano dati invii e spazi all’inserimento del nome dell’evento. Il programma continuerà a chiedere il nome dopo ogni invio e ignorerà gli spazi.

\end{itemize}


\subsubsection{Casi di test relativi alla tipologia dell'evento}

\begin{itemize}


	\item \textbf{TC007} : testiamo il caso in cui venga inserita la tipologia “2” dell’evento.

	\item \textbf{TC008} : testiamo il caso in cui venga inserita la tipologia “3” dell’evento.

	\item \textbf{TC009} : testiamo il caso in cui venga inserito 0 alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.

	\item \textbf{TC010} : testiamo il caso in cui venga inserito 4 alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.

	\item \textbf{TC011}: testiamo il caso in cui venga inserito -1 alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.

	\item \textbf{TC012}: testiamo il caso in cui venga inserita una stringa alla richiesta della tipologia dell’evento. Il programma chiederà nuovamente la tipologia.


\end{itemize}


\subsubsection{Casi di test relativi alle date dell'evento}

\begin{itemize}


	\item \textbf{TC013} : testiamo il caso in cui venga inserita una data con il giorno 0. Il programma chiederà nuovamente la data.

	\item \textbf{TC014} : testiamo il caso in cui venga inserita una data con il giorno -1. Il programma chiederà nuovamente la data.

	\item \textbf{TC015} : testiamo il caso in cui venga inserito 31 come giorno a gennaio.

	\item \textbf{TC016} : testiamo il caso  in cui venga inserito 32 come giorno. Il programma chiederà nuovamente la data.

	\item \textbf{TC017} : testiamo il caso  in cui venga inserito 28 come giorno a febbraio in un anno non bisestile.

	\item \textbf{TC018} : testiamo il caso  in cui venga inserito 29 come giorno a febbraio in un anno non bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC019} : testiamo il caso in cui venga inserito 29 come giorno a febbraio in un anno bisestile.

	\item \textbf{TC020} : testiamo il caso in cui venga inserito 30 come giorno a febbraio in un anno bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC021} : testiamo il caso in cui venga inserito 28 come giorno a febbraio in un anno non bisestile.

	\item \textbf{TC022} : testiamo il caso in cui venga inserito 29 come giorno a febbraio in un anno non bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC023} : testiamo il caso in cui venga inserito 29 come giorno a febbraio in un anno  bisestile.

	\item \textbf{TC024} : testiamo il caso  in cui venga inserito 30 come giorno a febbraio in un anno bisestile. Il programma chiederà nuovamente la data.

	\item \textbf{TC025} fino al \textbf{TC044} : testiamo tutti i casi in cui il giorno superi il limite di giorni in quel determinato mese. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC045} : testiamo il caso in cui venga inserito “13” come mese. Il programma chiederà nuovamente la data.

	\item \textbf{TC046} : testiamo il caso in cui venga inserito “00” come mese. Il programma chiederà nuovamente la data.

	\item \textbf{TC047} : testiamo il caso in cui venga inserito “-01” come mese. Il programma chiederà nuovamente la data.

	\item \textbf{TC048} : testiamo il caso in cui venga inserito “-01” come anno. Il programma chiederà nuovamente la data.

	\item \textbf{TC049} : testiamo il caso in cui venga inserito “24:00” come orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC050} : testiamo il caso in cui venga inserito “-1:00” come orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC051} : testiamo il caso in cui venga inserito “60” come minuti all’interno dell’orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC052} : testiamo il caso in cui venga inserito “-1” come minuti all’interno dell’orario. Il programma chiederà nuovamente la data.

	\item \textbf{TC053} : testiamo il caso in cui venga inserita come seconda data una data minore rispetto alla prima. Il programma chiederà nuovamente la data.

	\item \textbf{TC054} : testiamo il caso in cui venga inserita una data di inizio e di fine uguale. Andrea vaffanculo (spiegherai tu questa cosa).

	\item \textbf{TC054} : testiamo il caso in cui vengano inserite una data di inizio e una di fine uguale, abbiamo deciso di considerare corretto questo caso.

\end{itemize}


\subsection{Test per la rimozione di un evento}
I file conference.txt, output.txt e oracle.txt sono conferenze formattate come precedentemente descritto. Il formato del file input.txt è descritto nella sottosezione che segue.

\subsubsection{Formato del file \texttt{input.txt} per i Test di Rimozione Evento}

Per eseguire correttamente i test di aggiunta evento, il file \texttt{input.txt} deve essere formattato in modo specifico per rappresentare la rimozione di un singolo evento. Questo file contiene l'ID dell'evento da rimuovere.
Gli ID non validi vengono ignorati e la conferenza non viene cambiata


\paragraph{Esempio 1:}
Dato il seguente file conference.txt:
\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}

Di seguito è riportato un esempio di come deve essere formattato il file \texttt{input.txt}:

\begin{lstlisting}
1
\end{lstlisting}

In questo esempio 1 indica l'ID di ``Evento test 1''\\
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
2
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\paragraph{Esempio 2:}

Considerando la conferenza dell'esempio precedente di seguito si riporta il caso in cui venga inserito un ID non valido:

\begin{lstlisting}
4
\end{lstlisting}
Il valore 4 nella precedente conferenza non è ID di alcun evento.\\
Il file output.txt sarà quindi:

\begin{lstlisting}
4 2
3
1 0 0 Evento test 1
0 12 1 1 1970
0 13 1 1 1970
2 1 0 Evento test 2
0 12 1 1 1970
0 13 1 1 1970
3 2 0 Evento test 3
0 12 1 1 1970
0 13 1 1 1970
1
1
Sala A
50
\end{lstlisting}


\subsubsection{Casi di test}
\begin{itemize}

	\item \textbf{TC055} : testiamo il caso in cui venga rimosso l'evento con id 1.

	\item \textbf{TC056} : testiamo il caso in cui venga rimosso l'evento con id 2.

	\item \textbf{TC057} : testiamo il caso in cui venga rimosso l'evento con id 3.

	\item \textbf{TC058} : testiamo il caso in cui venga rimosso l'evento con id 3. Il programma non considererà la rimozione perché non è presente un evento con id 4.

	\item \textbf{TC059} : testiamo il caso in cui venga rimosso l'evento con id -1. Il programma non considererà la rimozione perché non è presente un evento con id -1.

\end{itemize}

\subsection{Test per la modifica di un evento}

\begin{itemize}

	\item \textbf{TC060} : testiamo il caso in cui venga modificato un evento già presente con id 0.

	\item \textbf{TC061} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, diamo un invio. Il programma chiederà di reinserire il nome dell'evento.

	\item \textbf{TC062} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, diamo degli spazi. Il programma non considererà gli spazi.

	\item \textbf{TC063} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, diamo un invio e degli spazi. Il programma ignorerà gli spazi e l'invio chiedendo di reinserire il nome dell'evento.

	\item \textbf{TC064} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, venga inserito un nome che superi il limite di 100 caratteri. Il programma chiederà di inserire nuovamente il nome dell'evento.

	\item \textbf{TC065} : testiamo il caso in cui nella modifica di un evento già presente, nell'inserimento del nome, venga inserito un nome di esattamente 100 caratteri.
	\item \textbf{TC066} : testiamo il caso in cui venga scelta una tipologia di evento corretta.

	\item \textbf{TC067} : testiamo il caso in cui venga scelta una tipologia di evento corretta.

	\item \textbf{TC068} : testiamo il caso in cui venga scelta una tipologia di evento corretta.

	\item \textbf{TC069} : testiamo il caso in cui venga inserito "0"  come tipologia di evento. Il programma ciederà nuovamente la tipologia.

	\item \textbf{TC070} : testiamo il caso in cui venga inserito "-1" come tipologia di evento. Il programma ciederà nuovamente la tipologia.

	\item \textbf{TC071} : testiamo il caso in cui venga inserito "4"  come tipologia di evento. Il programma ciederà nuovamente la tipologia.

	\item \textbf{TC072} : testiamo il caso in cui venga modificata correttamente la data di inizio.

	\item \textbf{TC073} : testiamo il caso in cui si tenti di inserire una data di inizio successiva rispetto a quella di fine. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC074} : testiamo il caso in cui si tenti di inserire una data di inizio che si sovrapponga alla data di un altro evento nella stessa sala. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC075} : testiamo il caso in cui venga modificata correttamente la data di fine.

	\item \textbf{TC076} : testiamo il caso in cui si tenti di inserire una data di fine precedente rispetto a quella di inizio. Il programma chiederà nuovamente di inserire la data.

	\item \textbf{TC077} : testiamo il caso in cui si tenti di inserire una data di fine che si sovrapponga alla data di un altro evento nella stessa sala. Il programma chiederà nuovamente di inserire la data.


\end{itemize}

\subsection{Test per l'assegnazione di una sala a un evento}

\begin{itemize}


	\item \textbf{TC078} : testiamo il caso in cui venga assegnata una sala ad un evento.

	\item \textbf{TC079} : testiamo il caso in cui venga assegnato ad un evento una sala già occupata nel periodo di tempo in cui si verifica.

	\item \textbf{TC080} : testiamo il caso in cui venga assegnata una sala ad un evento che ha la data di fine uguale alla data di inizio dell'evento successivo.

	\item \textbf{TC081} : testiamo il caso in cui venga assegnata una sala ad un evento che ha la data di inizio uguale alla data di fine dell'evento precedente.

	\item \textbf{TC082} : testiamo il caso in cui due eventi abbiano la stessa data di inizio e di fine, ma siano assegnati a sale differenti.


\end{itemize}

\subsection{Test per la liberazione di una sala assegnata a un evento}

\begin{itemize}

	\item \textbf{TC083} : testiamo la rimozione di una sala da un evento.

	\item \textbf{TC084} : testiamo la rimozione di una sala inesistente.

	\item \textbf{TC085} : testiamo che un numero negativo annulli la selezione di una sala.

\end{itemize}


\subsection{Test per la visualizzazione del programma dela conferenza}

\begin{itemize}


	\item \textbf{TC086} : testiamo la corretta visualizzazione degli eventi in ordine alfabetico, perché le date sono tutte uguali.

	\item \textbf{TC087} : testiamo la corretta visualizzazione degli eventi con id non ordinati.

	\item \textbf{TC088} : testiamo la corretta visualizzazione degli eventi con tutte le sale assegnate.

	\item \textbf{TC089} : testiamo la corretta visualizzazione degli eventi, con solo due sale assegnate a due eventi.

	\item \textbf{TC090} : testiamo la corretta visualizzazione degli eventi seguendo l'ordine delle date.

	\item \textbf{TC091} : visualizzazione di eventi multipli che combinano i precedenti test case.

	\item \textbf{TC092} : visualizzazione di lista di eventi vuota.
\end{itemize}

%-----------------------------------------------%

\end{document}
